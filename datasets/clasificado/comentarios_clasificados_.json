[
	{
		"comentario": "@petervdl heartbleed happened because someone got the great idea that reusing memory was cheaper than allocating new (cleared) memory, you cannot reuse a string in java, just hope that nobody ever gets the idea to put your char[] into a reuse list for better performance.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "it's referring to the fact that these annotations are good targets for aop, and while the other annotations do not define a pointcut yet, they might do that in the future. on the other hand @repository is already a target for a pointcut at present. that pointcut is used for exception translations, i.e. translating technology-specific exceptions to more generic spring-based ones, to avoid tight coupling.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"tight"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "1) underlying data structure the first difference between arraylist and linkedlist comes with the fact that arraylist is backed by array while linkedlist is backed by linkedlist. this will lead to further differences in performance. 2) linkedlist implements deque another difference between arraylist and linkedlist is that apart from the list interface, linkedlist also implements deque interface, which provides first in first out operations for add() and poll() and several other deque functions. 3) adding elements in arraylist adding element in arraylist is o(1) operation if it doesn't trigger re-size of array, in which case it becomes o(log(n)), on the other hand, appending an element in linkedlist is o(1) operation, as it doesn't require any navigation. 4) removing an element from a position in order to remove an element from a particular index e.g. by calling remove(index), arraylist performs a copy operation which makes it close to o(n) while linkedlist needs to traverse to that point which also makes it o(n/2), as it can traverse from either direction based upon proximity. 5) iterating over arraylist or linkedlist iteration is the o(n) operation for both linkedlist and arraylist where n is a number of an element. 6) retrieving element from a position the get(index) operation is o(1) in arraylist while its o(n/2) in linkedlist, as it needs to traverse till that entry. though, in big o notation o(n/2) is just o(n) because we ignore constants there. 7) memory linkedlist uses a wrapper object, entry, which is a static nested class for storing data and two nodes next and previous while arraylist just stores data in array. so memory requirement seems less in the case of arraylist than linkedlist except for the case where array performs the re-size operation when it copies content from one array to another. if array is large enough it may take a lot of memory at that point and trigger garbage collection, which can slow response time. from all the above differences between arraylist vs linkedlist, it looks arraylist is the better choice than linkedlist in almost all cases, except when you do a frequent add() operation than remove(), or get(). it's easier to modify a linked list than arraylist, especially if you are adding or removing elements from start or end because linked list internally keeps references of those positions and they are accessible in o(1) time. in other words, you don't need to traverse through the linked list to reach the position where you want to add elements, in that case, addition becomes o(n) operation. for example, inserting or deleting an element in the middle of a linked list. in my opinion, use arraylist over linkedlist for most of the practical purpose in java.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"deque"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "@mysticial perhaps, but i'm thinking pure latency here. we can worry about power consumption when my $200 laptop stops lagging and people start writing actually efficient code.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"pure"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "assuming it isn't a bug in the compiler, i would call this a severe and shocking flaw in the spec. malicious employees do exist, and they're dangerous enough without the language helping them this much.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"severe"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "the bytecode is pretty irrelevant for the performance unless you're forcing interpreted mode. write a jmh benchmark to see that the performance is exactly the same.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"pretty irrelevant",
				"exactly same"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "if i have an object implementing the code_removed interface in java and i wish to iterate over every pair contained within it, what is the most efficient way of going through the map? will the ordering of elements depend on the specific map implementation that i have for the interface?",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"remove"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "here is an oo solution (i.e., doesn't use code_removed methods): code_removed hereby donated to the public domain.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"public"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "(caveat: i am not a java programmer, i am a perl programmer. perl has no formal protections which is perhaps why i understand the problem so well:) ) private like you'd think, only the class in which it is declared can see it. package private can only be seen and used by the package in which it was declared. this is the default in java (which some see as a mistake). protected package private + can be seen by subclasses or package member. public everyone can see it. published visible outside the code i control. (while not java syntax, it is important for this discussion). c++ defines an additional level called \"friend\" and the less you know about that the better. when should you use what? the whole idea is encapsulation to hide information. as much as possible you want to hide the detail of how something is done from your users. why? because then you can change them later and not break anybody's code. this lets you optimize, refactor, redesign and fix bugs without worry that someone was using that code you just overhauled. so, rule of thumb is to make things only as visible as they have to be. start with private and only add more visibility as needed. only make public that which is absolutely necessary for the user to know, every detail you make public cramps your ability to redesign the system. if you want users to be able to customize behaviors, rather than making internals public so they can override them, it's often a better idea to shove those guts into an object and make that interface public. that way they can simply plug in a new object. for example, if you were writing a cd player and wanted the \"go find info about this cd\" bit customizable, rather than make those methods public you'd put all that functionality into its own object and make just your object getter/setter public. in this way being stingy about exposing your guts encourages good composition and separation of concerns personally, i stick with just \"private\" and \"public\". many oo languages just have that. \"protected\" can be handy, but it's really a cheat. once an interface is more than private it's outside of your control and you have to go looking in other people's code to find uses. this is where the idea of \"published\" comes in. changing an interface (refactoring it) requires that you find all the code which is using it and change that, too. if the interface is private, well no problem. if it's protected you have to go find all your subclasses. if it's public you have to go find all the code which uses your code. sometimes this is possible, for example if you're working on corporate code that's for internal use only it doesn't matter if an interface is public. you can grab all the code out of the corporate repository. but if an interface is \"published\", if there is code using it outside your control, then you're hosed. you must support that interface or risk breaking code. even protected interfaces can be considered published (which is why i don't bother with protected). many languages find the hierarchical nature of public/protected/private to be too limiting and not in line with reality. to that end there is the concept of a trait class, but that's another show.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"no",
				"formal"
			],
			"Interoperability": [
				"once private",
				"private",
				"public",
				"even",
				"protect"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": 0
		}
	},
	{
		"comentario": "the way to avoid unnecessary code_removed is simple to state: code_removed but, although it can be stated simply enough, achieving it is harder. the key lies in the code_removed part, because how can you be sure that a variable can't be null? there are no quick-fix, easy answers to this, but here are some pointers: clean code. the most important thing for being able to reason about the behaviour of a piece of code is that it is written in a matter that is easy to understand. name your variables based on what they represent, name your methods after what they do, apply the code_removed (the code_removed in code_removed: it means that each piece of code should have a single responsibility, and do this and nothing else). once your code is clean, it is much easier to reason about it, also across multiple tiers/layers of code. with messy code, trying to understand what a method does might make you forget why you are reading the method in the first place. (tip: read \"clean code\" by robert c. martin) avoid returning code_removed values. if a code_removed value would keep your program from functioning correctly, throw an code_removed instead (make sure to add the appropriate error-handling.) cases where returning a code_removed value might be acceptable is for instance trying to fetch an object from the database. in these cases, write code that handles the code_removed values, and make a note behind your ear that here we have something that might return code_removed. handle returned code_removed values as close to the caller of the method returning code_removed as possible (don't just blindly pass it back up the call-chain.) never ever pass explicit code_removed values as parameters (at least not across classes). if you are ever in a position where passing a code_removed-parameter is the only option, creating a new method that does not have this parameter is the way to go. validate your input! identify the \"entry-points\" to your application. they can everything from webservices, rest-services, remote ejb classes, controllers, etc. for each method in these entry-points, ask yourself: \"will this method execute correctly if this parameter is null?\" if the answer is no, add code_removed. this will throw an code_removed if the required parameter is missing. the good thing about this type of validation in the entry-points, is that you can then easily assume in the code being executed from the entry-point, that this variable will never be null! also, if this fails, being at the entry-point, debugging is made a lot easier than it would if you just got a code_removed deep down in your code, since a failure like this can only mean one thing: the client didn't send you all the required information. in most cases you want to validate all input parameters, if you find yourself in a position where you need to allow a lot of code_removed-values, it might be a sign of a badly designed interface, which needs refactoring/additions to suite the needs of the clients. when working with code_removeds, return an empty one rather than null! when working with a database, utilize code_removed-constraints. in that way, you'll know that a value read from the database cannot be null, and you won't have to check for it. structure your code and stick with it. doing this allows you to make assumptions about the behaviour of the code, for instance if all input to your application is validated, then you can assume that these values will never be null. if you are not already doing it, write automated tests of your code. by writing tests, you will reason about your code, and you will also become more confident that it does what it's supposed to. also, automated tests guards you from blunders during refactoring, by letting you know immediatly that this piece of code is not doing what it used to. you still have to null-check of course, but it can trimmed down to the bare minimum (i.e. the situation where know you might be getting a null-value, instead of everywhere just to be sure.) when it comes to null-checks, i actually prefer to use the ternary operator (but use with care, when you start nesting them they come really messy.) code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"badly design"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "moral of the story: inherit only if you want to override some behavior. or rather it should be read as: inherit less, interface more.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"more"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "in addition to what izb said, code_removed allows null values, whereas the code_removed does not. also note that code_removed extends the code_removed class, which as the javadocs state, is obsolete and has been replaced by the code_removed interface.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"remove"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "this question is often asked in interview to check whether candidate understands correct usage of collection classes and is aware of alternative solutions available. the hashmap class is roughly equivalent to hashtable, except that it is non synchronized and permits nulls. (hashmap allows null values as key and value whereas hashtable doesn't allow nulls). hashmap does not guarantee that the order of the map will remain constant over time. hashmap is non synchronized whereas hashtable is synchronized. iterator in the hashmap is fail-safe while the enumerator for the hashtable is not and throw concurrentmodificationexception if any other thread modifies the map structurally by adding or removing any element except iterator's own remove() method. but this is not a guaranteed behavior and will be done by jvm on best effort. note on some important terms synchronized means only one thread can modify a hash table at one point of time. basically, it means that any thread before performing an update on a hashtable will have to acquire a lock on the object while others will wait for lock to be released. fail-safe is relevant from the context of iterators. if an iterator has been created on a collection object and some other thread tries to modify the collection object \"structurally\", a concurrent modification exception will be thrown. it is possible for other threads though to invoke \"set\" method since it doesn't modify the collection \"structurally\". however, if prior to calling \"set\", the collection has been modified structurally, \"illegalargumentexception\" will be thrown. structurally modification means deleting or inserting element which could effectively change the structure of map. hashmap can be synchronized by code_removed map provides collection views instead of direct support for iteration via enumeration objects. collection views greatly enhance the expressiveness of the interface, as discussed later in this section. map allows you to iterate over keys, values, or key-value pairs; hashtable does not provide the third option. map provides a safe way to remove entries in the midst of iteration; hashtable did not. finally, map fixes a minor deficiency in the hashtable interface. hashtable has a method called contains, which returns true if the hashtable contains a given value. given its name, you'd expect this method to return true if the hashtable contained a given key, because the key is the primary access mechanism for a hashtable. the map interface eliminates this source of confusion by renaming the method containsvalue. also, this improves the interface's consistency \u2014 containsvalue parallels containskey. the map interface",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"hashtable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "\"once an interface is more than private it's outside of your control\" - that's only true for those ignoring package visibility as you do. all modifiers are important for information hiding and a package is usually authored by a small tightly cooperating team which treats all package visible methods as private to them. +++ similarly, code_removed isn't meant to wreak havoc on visibility, but to allow to tighten the rules more while adding an exception (any exception mechanism is prone to abuse; that's why package visibility is better, but maybe once a month i could use code_removed, too).",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"once private"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "i performed tests on eclipse vs netbeans 8.0.2, both with java version 1.8; i used code_removed for measurements. eclipse: i got the same time on both cases - around 1.564 seconds. netbeans: using \"#\": 1.536 seconds using \"b\": 44.164 seconds so, it looks like netbeans has bad performance on print to console. after more research i realized that the problem is line-wrapping of the max buffer of netbeans (it's not restricted to code_removed command), demonstrated by this code: code_removed the time results are less then 1 millisecond every iteration except every fifth iteration, when the time result is around 225 millisecond. something like (in nanoseconds): code_removed and so on.. summary: eclipse works perfectly with \"b\" netbeans has a line-wrapping problem that can be solved (because the problem does not occur in eclipse)(without adding space after b (\"b \")).",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"bad"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "rather for a long i was thinking to share this type of answer for this type of question. usually such cases are come in scope of a more meaningful logic, let's say some searching or manipulating over some of the iterated 'for'-objects in question, so i usually use the functional approach: code_removed major cons: roughly twice more lines more consumption of computing cycles, meaning it is slower from algorithmic point-of-view more typing work the pros: the higher ratio to separation of concerns because of functional granularity the higher ratio of re-usability and control of searching/manipulating logic without the methods are not long, thus they are more compact and easier to comprehend subjectively higher ratio of readability so it is just handling the case via a different approach. basically a question to the author of this question: what do you consider of this approach?",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
				"more"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "code_removed is similar to the code_removed and has a similar interface. it is recommended that you use code_removed, unless you require support for legacy applications or you need synchronisation, as the code_removed methods are synchronised. so in your case as you are not multi-threading, code_removed are your best bet.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"similar"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "class name, implemented interfaces, all public and protected methods,all instance variables.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"implement"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "@bruno sure, hardware-based tokens do not suffer from this, but what about situations where you are more or less forced to use a software key? not every deployment has the budget to afford an hsm. software key stores will at some point have to load the key into memory, so imo we should at least be given the option to clear the memory at will again.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
				"not"
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": -1,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": -1,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 0,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 0,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "here's a nifty utility i use: code_removed then in my enum class i usually have this to save some typing: code_removed if your enums are not all caps, just change the code_removed line. too bad i can't use code_removed for code_removed as code_removed is erased.",
		"aspectos": {
			"AvailabilityAndScalability": [
				"not"
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": -1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": -1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": 0,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": 0,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "rather for a long i was thinking to share this type of answer for this type of question. usually such cases are come in scope of a more meaningful logic, let's say some searching or manipulating over some of the iterated 'for'-objects in question, so i usually use the functional approach: code_removed major cons: roughly twice more lines more consumption of computing cycles, meaning it is slower from algorithmic point-of-view more typing work the pros: the higher ratio to separation of concerns because of functional granularity the higher ratio of re-usability and control of searching/manipulating logic without the methods are not long, thus they are more compact and easier to comprehend subjectively higher ratio of readability so it is just handling the case via a different approach. basically a question to the author of this question: what do you consider of this approach?",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
				"more"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "better use stringbuilder since it is not synchronized and therefor better performance. stringbuilder is a drop-in replacement of the older stringbuffer.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"therefor good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@jonskeet - in this question stackoverflow.com/questions/22397861/\u2026, most answers say that string immutability is great for security, which is opposite of your answer here. their \"reasoning\" - strings are often used to store connections, passwords etc. and immutability prevents them from being changed. they don't mention how a mutable string value getting changed could be a security problem. there is no mention of techniques that can be used to change mutable strings. could you please clarify? thanks.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"great"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		}
	},
	{
		"comentario": "by extending the thread class, the derived class can not extend any other base class because java only allow single inheritance. on the contrary, by implementing the runnable interface the class still extend other base class. the most significant difference between implementing runnable and extending thread is given below: by extending thread, derived class itself is a thread object, whereas implementing runnable interface it shares the same object to multiple threads.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable",
				"implement",
				"runnable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "some people believe that you have to overwrite the memory used to store the password once you no longer need it. this reduces the time window an attacker has to read the password from your system and completely ignores the fact that the attacker already needs enough access to hijack the jvm memory to do this. an attacker with that much access can catch your key events making this completely useless (afaik, so please correct me if i am wrong). update thanks to the comments i have to update my answer. apparently there are two cases where this can add a (very) minor security improvement as it reduces the time a password could land on the hard drive. still i think it's overkill for most use cases. your target system may be badly configured or you have to assume it is and you have to be paranoid about core dumps (can be valid if the systems are not managed by an administrator). your software has to be overly paranoid to prevent data leaks with the attacker gaining access to the hardware - using things like truecrypt (discontinued), veracrypt, or ciphershed. if possible, disabling core dumps and the swap file would take care of both problems. however, they would require administrator rights and may reduce functionality (less memory to use) and pulling ram from a running system would still be a valid concern.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"not"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "stringbuffer is mutable. it can change in terms of length and content. stringbuffers are thread-safe, meaning that they have synchronized methods to control access so that only one thread can access a stringbuffer object's synchronized code at a time. thus, stringbuffer objects are generally safe to use in a multi-threaded environment where multiple threads may be trying to access the same stringbuffer object at the same time. stringbuilder the stringbuilder class is very similar to stringbuffer, except that its access is not synchronized so that it is not thread-safe. by not being synchronized, the performance of stringbuilder can be better than stringbuffer. thus, if you are working in a single-threaded environment, using stringbuilder instead of stringbuffer may result in increased performance. this is also true of other situations such as a stringbuilder local variable (ie, a variable within a method) where only one thread will be accessing a stringbuilder object.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good",
				"increase"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "as data is distributed between 0 and 255 when the array is sorted, around the first half of the iterations will not enter the code_removed-statement (the code_removed statement is shared below). code_removed the question is: what makes the above statement not execute in certain cases as in case of sorted data? here comes the \"branch predictor\". a branch predictor is a digital circuit that tries to guess which way a branch (e.g. an code_removed structure) will go before this is known for sure. the purpose of the branch predictor is to improve the flow in the instruction pipeline. branch predictors play a critical role in achieving high effective performance! let's do some bench marking to understand it better the performance of an code_removed-statement depends on whether its condition has a predictable pattern. if the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. on the other hand, if the pattern is unpredictable, the code_removed-statement will be much more expensive. let\u2019s measure the performance of this loop with different conditions: code_removed here are the timings of the loop with different true-false patterns: code_removed a \u201cbad\u201d true-false pattern can make an code_removed-statement up to six times slower than a \u201cgood\u201d pattern! of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor. so there is no doubt about the impact of branch prediction on performance!",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"high",
				"effective",
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "asking that question points out that you may be interested in error handling strategies. your team's architect should decide how to work errors. there are several ways to do this: allow the exceptions to ripple through - catch them at the 'main loop' or in some other managing routine. check for error conditions and handle them appropriately sure do have a look at aspect oriented programming, too - they have neat ways to insert code_removed into your bytecode.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"interested"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "well so many good answers, i want to add more on this. this will help to understand code_removed.extends binds two class files very closely and can cause some pretty hard to deal with code. both approaches do the same job but there have been some differences. the most common difference is when you extends thread class, after that you can\u2019t extend any other class which you required. (as you know, java does not allow inheriting more than one class). when you implements runnable, you can save a space for your class to extend any other class in future or now. however, one significant difference between implementing runnable and extending thread is that code_removed the following example helps you to understand more clearly code_removed output of the above program. code_removed in the runnable interface approach, only one instance of a class is being created and it has been shared by different threads. so the value of counter is incremented for each and every thread access. whereas, thread class approach, you must have to create separate instance for every thread access. hence different memory is allocated for every class instances and each has separate counter, the value remains same, which means no increment will happen because none of the object reference is same. when to use runnable? use runnable interface when you want to access the same resource from the group of threads. avoid using thread class here, because multiple objects creation consumes more memory and it becomes a big performance overhead. a class that implements runnable is not a thread and just a class. for a runnable to become a thread, you need to create an instance of thread and passing itself in as the target. in most cases, the runnable interface should be used if you are only planning to override the code_removed method and no other thread methods. this is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class. when there is a need to extend a superclass, implementing the runnable interface is more appropriate than using the thread class. because we can extend another class while implementing runnable interface to make a thread. i hope this will help!",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable",
				"runnable",
				"runnable",
				"runnable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "@g_v there's definitely potential for memory leaks because an instance of the inner class keeps a reference to the outer class. whether this is an actual problem depends on where and how references to instances of the outer and the inner classes are held.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"definitely"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "there are no basic differences between stringbuilder and stringbuffer, only a few differences exist between them. in stringbuffer the methods are synchronized. this means that at a time only one thread can operate on them. if there are more than one thread then the second thread will have to wait for the first one to finish and the third one will have to wait for the first and second one to finish and so on. this makes the process very slow and hence the performance in case of stringbuffer is low. on the other hand stringbuilder is non synchronized. this means that at a time multiple threads can operate on the same strinbuilder object at the same time. this makes the process very fast and hence performance of stringbuilder is high.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"low",
				"very fast",
				"high"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "uses of reflection reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the java virtual machine. this is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. with that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible. extensibility features an application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names. class browsers and visual development environments a class browser needs to be able to enumerate the members of classes. visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code. debuggers and test tools debuggers need to be able to examine private members in classes. test harnesses can make use of reflection to systematically call a discoverable set apis defined on a class, to ensure a high level of code coverage in a test suite. drawbacks of reflection reflection is powerful, but should not be used indiscriminately. if it is possible to perform an operation without using reflection, then it is preferable to avoid using it. the following concerns should be kept in mind when accessing code via reflection. performance overhead because reflection involves types that are dynamically resolved, certain java virtual machine optimizations cannot be performed. consequently, reflective operations have slower performance than their non-reflective counterparts and should be avoided in sections of code which are called frequently in performance-sensitive applications. security restrictions reflection requires a runtime permission which may not be present when running under a security manager. this is in an important consideration for code which has to run in a restricted security context, such as in an applet. exposure of internals since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. reflective code breaks abstractions and therefore may change behavior with upgrades of the platform. source: the reflection api",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"important"
			],
			"Performance": [
				"slow"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "1) search: arraylist search operation is pretty fast compared to the linkedlist search operation. get(int index) in arraylist gives the performance of o(1) while linkedlist performance is o(n). reason: arraylist maintains an index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. on the other side, linkedlist implements a doubly linked list which requires the traversal through all the elements for searching an element. 2) deletion: linkedlist remove operation gives o(1) performance while arraylist gives variable performance: o(n) in the worst case (while removing the first element) and o(1) in the best case (while removing the last element). conclusion: linkedlist element deletion is faster compared to arraylist. reason: each of linkedlist\u2019s elements maintains two pointers (addresses), which point to both neighbor elements in the list. hence removal only requires a change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. while in arraylist all the elements need to be shifted to fill out the space created by removed element. 3) inserts performance: linkedlist add method gives o(1) performance while arraylist gives o(n) in the worst case. the reason is same as explained for remove. 4) memory overhead: arraylist maintains indexes and element data while linkedlist maintains element data and two pointers for neighbor nodes hence the memory consumption is high in linkedlist comparatively. there are few similarities between these classes which are as follows: both arraylist and linkedlist are implementations of list interface. they both maintain the elements insertion order which means while displaying arraylist and linkedlist elements the result set would be having the same order in which the elements got inserted into the list. both these classes are non-synchronized and can be made synchronized explicitly by using collections.synchronizedlist method. the iterator and listiterator returned by these classes are fail-fast (if the list is structurally modified at any time after the iterator is created, in any way except through the iterator\u2019s own remove or add methods, the iterator will throw a concurrentmodificationexception). when to use linkedlist and when to use arraylist? 1) as explained above the insert and remove operations give good performance (o(1)) in linkedlist compared to arraylist(o(n)). hence if there is a requirement of frequent addition and deletion in an application then linkedlist is the best choice. 2) search (get method) operations are fast in arraylist (o(1)) but not in linkedlist (o(n)) so if there are less add and remove operations and more search operations requirement, arraylist would be your best bet.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"variable",
				"good"
			],
			"Reliability": [
				"high"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@michaelb\u00f6ckling yes, the first method is written that way more as a consequence of the way code_removed works, and it doesn't provide a consistent output length or maximum bits of entropy per character. if you want the best security and best efficiency, i would use the second method, but initialize code_removed with a code_removed instance.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"best"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"best"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		}
	},
	{
		"comentario": "2) contains an error, it adds always \"null\" at the end of the string as you are always makeing one more step then necessary. performance will be the same anyway i think. this should work: string read = null; stringbuffer sb = new stringbuffer(); while((read = br.readline())!= null) { sb.append(read); }",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"same"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "if i am not wrong, it's more or less similar to what is the difference between an interface and abstract class? extends establishes \"is a\" relation & interface provides \"has a\" capability. prefer implements runnable: if you don't have to extend thread class and modify thread api default implementation if you are executing a fire and forget command if you are already extending another class prefer \"extends thread\": if you have to override any of these thread methods as listed in oracle documentation page generally you don't need to override thread behaviour. so implements runnable is preferred for most of the times. on a different note, using advanced code_removed or code_removed api provides more flexibility and control. have a look at this se question: executorservice vs casual thread spawner",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"abstract"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "@yassinhajaj both. for instance if you want to have a range stream over the array the idiomatic way using code_removed would be to do code_removed. the current implementation does not return a sized stream whereas code_removed does, leading to better splitting performances if you want to perform operations in parallel. also if you have an code_removed, you may accidentally use code_removed which will return a code_removed with a single element, while code_removed will give you an code_removed directly.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "as someone who has been doing operational performance engineering on very large scale soa web services for about a decade, i would prefer the behavior of linkedlist over arraylist. while the steady-state throughput of linkedlist is worse and therefore might lead to buying more hardware -- the behavior of arraylist under pressure could lead to apps in a cluster expanding their arrays in near synchronicity and for large array sizes could lead to lack of responsiveness in the app and an outage, while under pressure, which is catastrophic behavior. similarly, you can get better throughput in an app from the default throughput tenured garbage collector, but once you get java apps with 10gb heaps you can wind up locking up the app for 25 seconds during a full gcs which causes timeouts and failures in soa apps and blows your slas if it occurs too often. even though the cms collector takes more resources and does not achieve the same raw throughput, it is a much better choice because it has more predictable and smaller latency. arraylist is only a better choice for performance if all you mean by performance is throughput and you can ignore latency. in my experience at my job i cannot ignore worst-case latency.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"more predictable",
				"worst-case"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "there is such a method in apache commons-lang: code_removed. there is one more general: code_removed, which can be used to implement a degrading strategy: code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"degrading"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "@scott stanchfield very good explanation. i will just add that when using rmi, references are managed separately so even if we update one instance in one side a (somedog.setname(\"newname\")) and then return immediately, it will not get updated in the other side b. i will explain it in detail later if i got the time. regards.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"separately"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "@coolcfan - i do agree with you on that point. sometimes speed is of the utmost importance and is a hard requirement. many times, good enough is good enough. i question how often we put effort into optimizing something that no one notices. the answer of whether the reward is greater than the cost is a decision not to be taken lightly. thank you for indicating that there are times when this is necessary.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
				"great"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@igal i didn't measure it. if you do, gist it and i'll append your results to the answer.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"n't"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@milixyron: well code_removed is just an interface, which code_removed implements. it doesn't provide any way of clearing it, leading to the same problems.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"just"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "with eclipse collections (formerly gs collections), you would use the foreachkeyvalue method on the mapiterable interface, which is inherited by the mutablemap and immutablemap interfaces and their implementations. code_removed with java 8 lambda syntax, you can write the code as follows: code_removed note: i am a committer for eclipse collections.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"mapiterable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "wouldn't another solution be managing the size of the list programmatically by using the arraylist's ensurecapacity() method? my question is why are so many things being stored in a bunch of brittle data structures when they might better be stored in a caching or db mechanism? i had an interview the other day where they swore up and down about the evils of arraylist, but i come here and i find that the complexity analysis is all-around better! great point for discussion, though. thanks!",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"n't",
				"programmatically"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "as what has already been mentioned by others, what behind the mystery is branch predictor. i'm not trying to add something but explaining the concept in another way. there is a concise introduction on the wiki which contains text and diagram. i do like the explanation below which uses a diagram to elaborate the branch predictor intuitively. in computer architecture, a branch predictor is a digital circuit that tries to guess which way a branch (e.g. an if-then-else structure) will go before this is known for sure. the purpose of the branch predictor is to improve the flow in the instruction pipeline. branch predictors play a critical role in achieving high effective performance in many modern pipelined microprocessor architectures such as x86. two-way branching is usually implemented with a conditional jump instruction. a conditional jump can either be \"not taken\" and continue execution with the first branch of code which follows immediately after the conditional jump, or it can be \"taken\" and jump to a different place in program memory where the second branch of code is stored. it is not known for certain whether a conditional jump will be taken or not taken until the condition has been calculated and the conditional jump has passed the execution stage in the instruction pipeline (see fig. 1). based on the described scenario, i have written an animation demo to show how instructions are executed in a pipeline in different situations. without the branch predictor. without branch prediction, the processor would have to wait until the conditional jump instruction has passed the execute stage before the next instruction can enter the fetch stage in the pipeline. the example contains three instructions and the first one is a conditional jump instruction. the latter two instructions can go into the pipeline until the conditional jump instruction is executed. it will take 9 clock cycles for 3 instructions to be completed. use branch predictor and don't take a conditional jump. let's assume that the predict is not taking the conditional jump. it will take 7 clock cycles for 3 instructions to be completed. use branch predictor and take a conditional jump. let's assume that the predict is not taking the conditional jump. it will take 9 clock cycles for 3 instructions to be completed. the time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. as a result, making a pipeline longer increases the need for a more advanced branch predictor. as you can see, it seems we don't have a reason not to use branch predictor. it's quite a simple demo that clarifies the very basic part of branch predictor. if those gifs are annoying, please feel free to remove them from the answer and visitors can also get the demo from git",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"high",
				"effective",
				"longer"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "1) search: arraylist search operation is pretty fast compared to the linkedlist search operation. get(int index) in arraylist gives the performance of o(1) while linkedlist performance is o(n). reason: arraylist maintains an index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. on the other side, linkedlist implements a doubly linked list which requires the traversal through all the elements for searching an element. 2) deletion: linkedlist remove operation gives o(1) performance while arraylist gives variable performance: o(n) in the worst case (while removing the first element) and o(1) in the best case (while removing the last element). conclusion: linkedlist element deletion is faster compared to arraylist. reason: each of linkedlist\u2019s elements maintains two pointers (addresses), which point to both neighbor elements in the list. hence removal only requires a change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. while in arraylist all the elements need to be shifted to fill out the space created by removed element. 3) inserts performance: linkedlist add method gives o(1) performance while arraylist gives o(n) in the worst case. the reason is same as explained for remove. 4) memory overhead: arraylist maintains indexes and element data while linkedlist maintains element data and two pointers for neighbor nodes hence the memory consumption is high in linkedlist comparatively. there are few similarities between these classes which are as follows: both arraylist and linkedlist are implementations of list interface. they both maintain the elements insertion order which means while displaying arraylist and linkedlist elements the result set would be having the same order in which the elements got inserted into the list. both these classes are non-synchronized and can be made synchronized explicitly by using collections.synchronizedlist method. the iterator and listiterator returned by these classes are fail-fast (if the list is structurally modified at any time after the iterator is created, in any way except through the iterator\u2019s own remove or add methods, the iterator will throw a concurrentmodificationexception). when to use linkedlist and when to use arraylist? 1) as explained above the insert and remove operations give good performance (o(1)) in linkedlist compared to arraylist(o(n)). hence if there is a requirement of frequent addition and deletion in an application then linkedlist is the best choice. 2) search (get method) operations are fast in arraylist (o(1)) but not in linkedlist (o(n)) so if there are less add and remove operations and more search operations requirement, arraylist would be your best bet.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"variable",
				"good"
			],
			"Reliability": [
				"high"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "why is this solution any better than code_removed? with code_removed you get npe protection, easy-to-read code, and compile time type compatibility checking, and you get all of those without writing any custom equals-like methods.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"npe"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		}
	},
	{
		"comentario": "a code_removed \u2014 sometimes called a container \u2014 is simply an object that groups multiple elements into a single unit. code_removeds are used to store, retrieve, manipulate, and communicate aggregate data. a collections framework w is a unified architecture for representing and manipulating collections. the code_removed code_removed and hashtable code_removed, both are used to represent a group of objects that are represented in code_removed pair. each code_removed pair is called code_removed object. the collection of entries is referred by the object of code_removed and code_removed. keys in a collection must be unique or distinctive. [as they are used to retrieve a mapped value a particular key. values in a collection can be duplicated.] \u00ab superclass, legacy and collection framework member hashtable is a legacy class introduced in code_removed, which is a subclass of dictionary class. from code_removed hashtable is re-engineered to implement the map interface to make a member of collection framework. hashmap is a member of java collection framework right from the beginning of its introduction in code_removed. hashmap is the subclass of the abstractmap class. code_removed \u00ab initial capacity and load factor the capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. note that the hash table is open: in the case of a \"code_removedcode_removed\", a single bucket stores multiple entries, which must be searched sequentially. the load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. hashmap constructs an empty hash table with the default initial capacity (16) and the default load factor (0.75). where as hashtable constructs empty hashtable with a default initial capacity (11) and load factor/fill ratio (0.75). \u00ab structural modification in case of hash collision code_removed, code_removed in case of hash collisions they store the map entries in linked lists. from java8 for code_removed if hash bucket grows beyond a certain threshold, that bucket will switch from code_removed. which improve worst-case performance from o(n) to o(log n). while converting the list to binary tree, hashcode is used as a branching variable. if there are two different hashcodes in the same bucket, one is considered bigger and goes to the right of the tree and other one to the left. but when both the hashcodes are equal, code_removed assumes that the keys are comparable, and compares the key to determine the direction so that some order can be maintained. it is a good practice to make the keys of code_removed comparable. on adding entries if bucket size reaches code_removed convert linked list of entries to a balanced tree, on removing entries less than code_removed and at most code_removed will reconvert balanced tree to linked list of entries. java 8 src, stackpost \u00ab collection-view iteration, fail-fast and fail-safe code_removed code_removed is a fail-fast in nature. i.e it throws concurrentmodificationexception if a collection is modified while iterating other than it\u2019s own remove() method. where as code_removed is fail-safe in nature. it doesn\u2019t throw any exceptions if a collection is modified while iterating. according to java api docs, iterator is always preferred over the enumeration. note: the functionality of enumeration interface is duplicated by the iterator interface. in addition, iterator adds an optional remove operation, and has shorter method names. new implementations should consider using iterator in preference to enumeration. in java 5 introduced concurrentmap interface: code_removed - a highly concurrent, high-performance code_removed implementation backed by a hash table. this implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. it is intended as a drop-in replacement for code_removed: in addition to implementing code_removed, it supports all of the \"legacy\" methods peculiar to code_removed. each code_removeds value is volatile thereby ensuring fine grain consistency for contended modifications and subsequent reads; each read reflects the most recently completed update iterators and enumerations are fail safe - reflecting the state at some point since the creation of iterator/enumeration; this allows for simultaneous reads and modifications at the cost of reduced consistency. they do not throw concurrentmodificationexception. however, iterators are designed to be used by only one thread at a time. like code_removed but unlike code_removed, this class does not allow null to be used as a key or value. code_removed \u00ab null keys and null values code_removed allows maximum one null key and any number of null values. where as code_removed doesn\u2019t allow even a single null key and null value, if the key or value null is then it throws nullpointerexception. example \u00ab synchronized, thread safe code_removed is internally synchronized. therefore, it is very much safe to use code_removed in multi threaded applications. where as code_removed is not internally synchronized. therefore, it is not safe to use code_removed in multi threaded applications without external synchronization. you can externally synchronize code_removed using code_removed method. \u00ab performance as code_removed is internally synchronized, this makes code_removed slightly slower than the code_removed. @see a red\u2013black tree is a kind of self-balancing binary search tree performance improvement for code_removed in java 8",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"automatically",
				"worst-case"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"introduce"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "what is much clearer now than 1995 is that you better know english if you want to program. programming is an international interaction, and almost all resources are in english.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"international",
				"english"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "stringbuffer is mutable. it can change in terms of length and content. stringbuffers are thread-safe, meaning that they have synchronized methods to control access so that only one thread can access a stringbuffer object's synchronized code at a time. thus, stringbuffer objects are generally safe to use in a multi-threaded environment where multiple threads may be trying to access the same stringbuffer object at the same time. stringbuilder the stringbuilder class is very similar to stringbuffer, except that its access is not synchronized so that it is not thread-safe. by not being synchronized, the performance of stringbuilder can be better than stringbuffer. thus, if you are working in a single-threaded environment, using stringbuilder instead of stringbuffer may result in increased performance. this is also true of other situations such as a stringbuilder local variable (ie, a variable within a method) where only one thread will be accessing a stringbuilder object.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good",
				"increase"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@bestass sorry, but code_removed is pretty well understood and how it behaves in the jvm... there are good reasons to use code_removed in place of code_removed when dealing with passwords in a secure manner.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"secure"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@evusas i'm not a hardware designer, so i don't know the answer for sure. but the rollback logic certainly isn't free. even if the cpu designers managed to completely hide the performance impact of a misprediction roll-back, there are still costs in terms of power consumption of the wasted computation. today's chips are very power optimized and will vary their clock speeds to stay under a power limit. so it's certainly within the realm of possibility that excessive waste of power from mispredictions can indirectly hurt performance.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"even"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "uses of reflection reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the java virtual machine. this is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. with that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible. extensibility features an application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names. class browsers and visual development environments a class browser needs to be able to enumerate the members of classes. visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code. debuggers and test tools debuggers need to be able to examine private members in classes. test harnesses can make use of reflection to systematically call a discoverable set apis defined on a class, to ensure a high level of code coverage in a test suite. drawbacks of reflection reflection is powerful, but should not be used indiscriminately. if it is possible to perform an operation without using reflection, then it is preferable to avoid using it. the following concerns should be kept in mind when accessing code via reflection. performance overhead because reflection involves types that are dynamically resolved, certain java virtual machine optimizations cannot be performed. consequently, reflective operations have slower performance than their non-reflective counterparts and should be avoided in sections of code which are called frequently in performance-sensitive applications. security restrictions reflection requires a runtime permission which may not be present when running under a security manager. this is in an important consideration for code which has to run in a restricted security context, such as in an applet. exposure of internals since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. reflective code breaks abstractions and therefore may change behavior with upgrades of the platform. source: the reflection api",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"important"
			],
			"Performance": [
				"slow"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "this method will just serve the purpose. (the 'setback' is that the values must implement the java.util.comparable interface) code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"java.util.comparable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "code_removed and code_removed have significant algorithmic differences as well. no one has mentioned this before so that's why i am bringing it up. code_removed will construct a hash table with power of two size, increase it dynamically such that you have at most about eight elements (collisions) in any bucket and will stir the elements very well for general element types. however, the code_removed implementation provides better and finer control over the hashing if you know what you are doing, namely you can fix the table size using e.g. the closest prime number to your values domain size and this will result in better performance than hashmap i.e. less collisions for some cases. separate from the obvious differences discussed extensively in this question, i see the hashtable as a \"manual drive\" car where you have better control over the hashing and the hashmap as the \"automatic drive\" counterpart that will generally perform well.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "can code_removed be used on code_removed? yes: enums have tight instance controls that allows you to use code_removed to compare instances. here's the guarantee provided by the language specification (emphasis by me): jls 8.9 enums an enum type has no instances other than those defined by its enum constants. it is a compile-time error to attempt to explicitly instantiate an enum type. the code_removed method in code_removed ensures that code_removed constants can never be cloned, and the special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization. reflective instantiation of enum types is prohibited. together, these four things ensure that no instances of an code_removed type exist beyond those defined by the code_removed constants. because there is only one instance of each code_removed constant, it is permissible to use the code_removed operator in place of the code_removed method when comparing two object references if it is known that at least one of them refers to an code_removed constant. (the code_removed method in code_removed is a code_removed method that merely invokes code_removed on its argument and returns the result, thus performing an identity comparison.) this guarantee is strong enough that josh bloch recommends, that if you insist on using the singleton pattern, the best way to implement it is to use a single-element code_removed (see: effective java 2nd edition, item 3: enforce the singleton property with a private constructor or an enum type; also thread safety in singleton) what are the differences between code_removed and code_removed? as a reminder, it needs to be said that generally, code_removed is not a viable alternative to code_removed. when it is, however (such as with code_removed), there are two important differences to consider: code_removed never throws code_removed code_removed code_removed is subject to type compatibility check at compile time code_removed should code_removed be used when applicable? bloch specifically mentions that immutable classes that have proper control over their instances can guarantee to their clients that code_removed is usable. code_removed is specifically mentioned to exemplify. item 1: consider static factory methods instead of constructors [...] it allows an immutable class to make the guarantee that no two equal instances exist: code_removed if and only if code_removed. if a class makes this guarantee, then its clients can use the code_removed operator instead of the code_removed method, which may result in improved performance. enum types provide this guarantee. to summarize, the arguments for using code_removed on code_removed are: it works. it's faster. it's safer at run-time. it's safer at compile-time.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"improve"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "this is easily achievable without any external libraries. 1. cryptographic pseudo random data generation first you need a cryptographic prng. java has code_removed for that typically uses the best entropy source on the machine (e.g. code_removed). read more here. code_removed note: code_removed is the slowest, but most secure way in java of generating random bytes. i do however recommend not considering performance here since it usually has no real impact on your application unless you have to generate millions of tokens per second. 2. required space of possible values next you have to decide \"how unique\" your token needs to be. the whole and only point of considering entropy is to make sure that the system can resist brute force attacks: the space of possible values must be so large that any attacker could only try a negligible proportion of the values in non-ludicrous time1. unique identifiers such as random code_removed have 122bit of entropy (ie. 2^122 = 5.3x10^36) - the chance of collision is \"*(...) for there to be a one in a billion chance of duplication, 103 trillion version 4 uuids must be generated2\". we will choose 128 bit since it fits exactly into 16 bytes and is seen as highly sufficient for being unique for basically every, but the most extreme, use cases and you don't have to think about duplicates. here is a simple comparison table of entropy including simple analysis of the birthday problem. for simple requirements 8 or 12 byte length might suffice, but with 16 bytes you are on the \"safe side\". and that's basically it. last thing is to think about encoding so it can be represented as a printable text (read, a code_removed). 3. binary to text encoding typical encodings include: code_removed every character encodes 6bit creating a 33% overhead. unfortunatly there is no standard implementation in the jdk (7 and below - there is in android and java 8+). but numerous libraries exist that add this. the downside is, that standard code_removed is not safe for eg. urls and as filename in most file systems requiring additional encoding (e.g. url encoding) or the url safe version of base64 is used. example encoding 16 bytes with padding: code_removed code_removed every character encodes 5bit creating a 40% overhead. this will use code_removed and code_removed making it reasonably space efficient while being case-insensitive alpha-numeric. there is no standard implementation in the jdk. example encoding 16 bytes without padding: code_removed code_removed (hex) every character encodes 4bit requiring 2 characters per byte (ie. 16 byte create a string of length 32). therefore hex is less space efficient than code_removed but is safe to use in most cases (url) since it only uses code_removed and code_removed to code_removed. example encoding 16 bytes: code_removed. see a so discussion about converting to hex here. additional encodings like base85 and the exotic base122 exist with better/worse space efficiency. you can create your own encoding (which basically most answers in this thread do) but i would advise against it, if you don't have very specific requirements. see more encoding schemes in the wikipedia article. 4. summary and example use code_removed use at least 16 bytes (2^128) of possible values encode according to your requirements (usually code_removed or code_removed if you need it to be alpha-numeric) don't ... use your home brew encoding: better maintainable and readable for others if they see what standard encoding you use instead of weird for loops creating chars at a time. ... use uuid: you are wasting 6bits of entropy and have verbose string representation example: hex token generator code_removed example: tool if you want a ready-to-use cli tool you may use dice:",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"better/worse"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@vladlifliand how exactly would a utf-8 character manage to span across several lines? that's impossible by definition. you probably meant something else.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"how exactly"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "@djule5 130 bits in base32 gives 4x the security in 81% of the space, relative to 128 bits in hexadecimal. but you're right, 130 was rounded up from 128 because 128 bits is considered strong security.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"strong"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		}
	},
	{
		"comentario": "i've done a better version of your benchmark here, with results - the append-on-end performance for the arraylist is artificially low for yours, because addall is giving a storage array of exactly initial size, so the first insert always triggers an arraycopy. also, this includes warmup cycles to allow for jit compilation before data is collected.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"append-on-end",
				"artificially low"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "actually, if you use hashset as tom hawtin proposed you don`t need to worry about sorting and your speed is the same as with binary search on a presorted array, probably even faster. it all depends on how your code is set up, obviously, but from where i stand, the order would be: on an unsorted array: hashset aslist sort & binary on a sorted array: hashset binary aslist so either way, hashset ftw",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"same"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "difference between @component, @service and @repository major difference between these stereotypes is they are used for different classification. in a multitier application, we will have different layers like presentation, service, business, data access etc. when a class is to be annotated for auto-detection by spring, then we should use the respective stereotype as below. code_removed \u2013 generic and can be used across application. code_removed \u2013 annotate classes at service layer level. code_removed \u2013 annotate classes at persistence layer, which will act as database repository. if technically they are going to be same then why do we need to use these at different layers level. why not use the same at all layers. for example, if we use code_removed in all layers, all the beans will get instantiated and no issues. there is a minor difference, for example consider code_removed. the postprocessor automatically looks for all exception translators (implementations of the persistenceexceptiontranslator interface) and advises all beans marked with the code_removed annotation so that the discovered translators can intercept and apply the appropriate translation on the thrown exceptions. similar to the above, in future spring may choose to add value for code_removed, code_removed and code_removed based on their layering conventions. to that additional feature advantage its better to respect the convention and use them in line with layers. other than the above, with respect to scan-auto-detection, dependency injection for beandefinition code_removed, code_removed, code_removed, code_removed are same.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"different"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "ok, i see your benchmarks, but whole branch prediction thing doesn't provide much performance. it introduces more problems than solving it. then why cpu manufactures even bothered integrating such thing in it?",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"much"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@ted hopp: i can\u2019t speak for linux, but windows does clear memory pages. it\u2019s not clear why this should be slow at all, that happens once for each allocated page and it doesn\u2019t even need to happen on the allocation, but the first actual use, though there\u2019s also a background clearing of unused pages in advance when cpu cycles are free. the reason is exactly security. that doesn\u2019t affect the difference between code_removed and code_removed as these are not operating system, c library functions. so code_removed might return non-zero memory which the same program has freed earlier\u2026",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"exactly"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		}
	},
	{
		"comentario": "this is discussed in oracle's defining and starting a thread tutorial: which of these idioms should you use? the first idiom, which employs a runnable object, is more general, because the runnable object can subclass a class other than thread. the second idiom is easier to use in simple applications, but is limited by the fact that your task class must be a descendant of thread. this lesson focuses on the first approach, which separates the runnable task from the thread object that executes the task. not only is this approach more flexible, but it is applicable to the high-level thread management apis covered later. in other words, implementing code_removed will work in scenarios where your class extends a class other than code_removed. java does not support multiple inheritance. also, extending code_removed will not be possible when using some of the high-level thread management apis. the only scenario where extending code_removed is preferable is in a small application that won't be subject to updates in future. it is almost always better to implement code_removed as it is more flexible as your project grows. a design change won't have a major impact as you can implement many interfaces in java, but only extend one class.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"many"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "what i don't like about delegation is the need to hold a reference to the delegate. and every reference means more memory. correct me if i'm wrong. if i need a customizedarraylist of 100 objects then this wouldn't matter much but if i need hundreds of customizdearraylists of a few objects then memory usage increases significantly.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"significantly"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "for arrays of limited length use the following (as given by camickr). this is slow for repeated checks, especially for longer arrays (linear search). code_removed for fast performance if you repeatedly check against a larger set of elements an array is the wrong structure. use a code_removed and add each element to it. it sorts elements and has a fast code_removed method (binary search). if the elements implement code_removed & you want the code_removed sorted accordingly: code_removed method must be compatable with code_removed: see triads not showing up to fight? (java set missing an item) code_removed otherwise, use your own code_removed: code_removed the payoff: check existence of some element: code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"fast"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@milixyron: well code_removed is just an interface, which code_removed implements. it doesn't provide any way of clearing it, leading to the same problems.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"just"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "@zero i am with you brother i get what you are saying. since thread class itself implements runnable interface, so any instance of a class extending the thread class can be passed in to creating code_removed in the running process i.e (as you rightly said) code_removed now these two thread will share same instance i.e code_removed, where as in this case not [please read the below comment for completion]",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "code_removed and code_removed both implements code_removed and their methods and results are almost identical. however there are few differences between them which make one better over another depending on the requirement. arraylist vs linkedlist 1) code_removed code_removed search operation is pretty fast compared to the code_removed search operation. code_removed in code_removed gives the performance of code_removed while code_removed performance is code_removed. code_removed code_removed maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. on the other side code_removed implements doubly linked list which requires the traversal through all the elements for searching an element. 2) code_removed code_removed remove operation gives code_removed performance while code_removed gives variable performance: code_removed in worst case (while removing first element) and code_removed in best case (while removing last element). conclusion: linkedlist element deletion is faster compared to arraylist. reason: linkedlist\u2019s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. while in arraylist all the elements need to be shifted to fill out the space created by removed element. 3) code_removed code_removed add method gives code_removed performance while code_removed gives code_removed in worst case. reason is same as explained for remove. 4) code_removed code_removed maintains indexes and element data while code_removed maintains element data and two pointers for neighbor nodes hence the memory consumption is high in linkedlist comparatively. there are few similarities between these classes which are as follows: both arraylist and linkedlist are implementation of list interface. they both maintain the elements insertion order which means while displaying arraylist and linkedlist elements the result set would be having the same order in which the elements got inserted into the list. both these classes are non-synchronized and can be made synchronized explicitly by using collections.synchronizedlist method. the code_removed and code_removed returned by these classes are code_removed (if list is structurally modified at any time after the iterator is created, in any way except through the code_removed own remove or add methods, the iterator will code_removed a code_removed). when to use linkedlist and when to use arraylist? as explained above the insert and remove operations give good performance code_removed in code_removed compared to code_removed. hence if there is a requirement of frequent addition and deletion in application then linkedlist is a best choice. search (code_removed) operations are fast in code_removed but not in code_removed so if there are less add and remove operations and more search operations requirement, arraylist would be your best bet.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"variable"
			],
			"Reliability": [
				"high"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "threadlocalrandom equivalent of class java.util.random for multithreaded environment. generating a random number is carried out locally in each of the threads. so we have a better performance by reducing the conflicts. code_removed x,y - intervals e.g. (1,10)",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "null is not a 'problem'. it is an integral part of a complete modeling tool set. software aims to model the complexity of the world and null bears its burden. null indicates 'no data' or 'unknown' in java and the like. so it is appropriate to use nulls for these purposes. i don't prefer the 'null object' pattern; i think it rise the 'who will guard the guardians' problem. if you ask me what is the name of my girlfriend i'll tell you that i have no girlfriend. in the java language i'll return null. an alternative would be to throw meaningful exception to indicate some problem that can't be (or don't want to be) solved right there and delegate it somewhere higher in the stack to retry or report data access error to the user. for an 'unknown question' give 'unknown answer'. (be null-safe where this is correct from business point of view) checking arguments for null once inside a method before usage relieves multiple callers from checking them before a call. code_removed previous leads to normal logic flow to get no photo of a non-existent girlfriend from my photo library. code_removed and it fits with new coming java api (looking forward) code_removed while it is rather 'normal business flow' not to find photo stored into the db for some person, i used to use pairs like below for some other cases code_removed and don't loathe to type code_removed (generate javadoc in eclipse) and write three additional words for you public api. this will be more than enough for all but those who don't read documentation. code_removed or code_removed this is rather theoretical case and in most cases you should prefer java null safe api (in case it will be released in another 10 years), but code_removed is subclass of an code_removed. thus it is a form of code_removed that indicates conditions that a reasonable application might want to catch (javadoc)! to use the first most advantage of exceptions and separate error-handling code from 'regular' code (according to creators of java) it is appropriate, as for me, to catch code_removed. code_removed questions could arise: q. what if code_removed returns null? a. it is up to business logic. if i fail to find a photo album i'll show you no photos. what if appcontext is not initialized? this method's business logic puts up with this. if the same logic should be more strict then throwing an exception it is part of the business logic and explicit check for null should be used (case 3). the new java null-safe api fits better here to specify selectively what implies and what does not imply to be initialized to be fail-fast in case of programmer errors. q. redundant code could be executed and unnecessary resources could be grabbed. a. it could take place if code_removed would try to open a database connection, create code_removed and use the person name as an sql parameter at last. the approach for an unknown question gives an unknown answer (case 1) works here. before grabbing resources the method should check parameters and return 'unknown' result if needed. q. this approach has a performance penalty due to the try closure opening. a. software should be easy to understand and modify firstly. only after this, one could think about performance, and only if needed! and where needed! (source), and many others). ps. this approach will be as reasonable to use as the separate error-handling code from \"regular\" code principle is reasonable to use in some place. consider the next example: code_removed pps. for those fast to downvote (and not so fast to read documentation) i would like to say that i've never caught a null-pointer exception (npe) in my life. but this possibility was intentionally designed by the java creators because npe is a subclass of code_removed. we have a precedent in java history when code_removed is an code_removed not because it is actually an application error, but solely because it was not intended to be caught! how much npe fits to be an code_removed than code_removed! but it is not. check for 'no data' only if business logic implies it. code_removed and code_removed if appcontext or datasource is not initialized unhandled runtime nullpointerexception will kill current thread and will be processed by thread.defaultuncaughtexceptionhandler (for you to define and use your favorite logger or other notification mechanizm). if not set, threadgroup#uncaughtexception will print stacktrace to system err. one should monitor application error log and open jira issue for each unhandled exception which in fact is application error. programmer should fix bug somewhere in initialization stuff.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"regular"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@thor84no saying that the method doesn't work \"that way\" implies you have a clear idea of what i was saying, and that what i was saying was wrong. anyhow, at least 128 bits is preferred for strong security. 25 base-32 digits will only hold 125 bits, so you need 26 base-32 digits. but, 32^26 exactly equals 2^130, so you can squeeze a couple of extra bits in without any additional characters. if you use base 36 instead, you can fit 129 bits into 25 characters, but there is some wasted space (a quarter of a bit).",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"strong"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		}
	},
	{
		"comentario": "note that this assumes that the inputstream has all bytes immediately available. that's usually not the case: typically you read from some io interface. i'm curious if that would change the results. with networking for example, perhaps it's better to to the conversion of the bytes using the charset decoder while reading so that meanwhile the underlying protocol can buffer more data.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"underlie"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "simple way to say is: if you implement interface that means you are implementing all methods of it and if you extending the class you are inheriting method of your choice... in this case,there is only a one method named run() so better to implement runnable interface..",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "as of api 21 (the first android 5.0/lollipop sdk), this detects whether the goat simulator app is installed: code_removed this should make it clear that djechlin's suggestion of using it as a warning-free code_removed is a potentially disastrous strategy. what previously returned code_removed for every device now returns a seemingly random value: if this was buried deep enough in your code it could take a long time to figure out where your new bugs are coming from. bottom line: if you don't control the implementation of a method and decide to use it for purposes other than stated in the api documentation, you're heading for trouble.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"potentially disastrous"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "with the release of java 8, there is now a third option. code_removed is a functional interface, which means that instances of it can be created with lambda expressions or method references. your example can be replaced with: code_removed or if you want to use an code_removed and a method reference: code_removed these are not only much shorter than your examples, but also come with many of the advantages stated in other answers of using code_removed over code_removed, such as single responsibility and using composition because you're not specializing the thread's behaviour. this way also avoids creating an extra class if all you need is a code_removed as you do in your examples.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"functional"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "java is focused towards code maintainability so they didn't include featuers that made code harder to maintain. for the most part these features allwed people to hand-optimize code where the compiler couldn't, but the java runtime allows an alternative so that featuers like free pointers and references just don't give that much of a performance boost to make them worth the destabilizing effect. c/c++ offer a different path--you don't have to trust a runtime and have more control over the hardware. both are valid, but pass by ref and pointers would be really bad ideas in java.",
		"aspectos": {
			"AvailabilityAndScalability": [
				"much"
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": 1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": 1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": 1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": 1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "if you want to implements or extends any other class then code_removed interface is most preferable other wise if you do not want any other class to extend or implement then code_removed class is preferable the most common difference is when you code_removed class, after that you can\u2019t extend any other class which you required. (as you know, java does not allow inheriting more than one class). when you code_removed, you can save a space for your class to extend any other class in future or now. java doesn't support multiple inheritance, which means you can only extend one class in java so once you extended thread class you lost your chance and can not extend or inherit another class in java. in object oriented programming extending a class generally means adding new functionality, modifying or improving behaviors. if we are not making any modification on thread then use runnable interface instead. runnable interface represent a task which can be executed by either plain thread or executors or any other means. so logical separation of task as runnable than thread is good design decision. separating task as runnable means we can reuse the task and also has liberty to execute it from different means. since you can not restart a thread once it completes. again runnable vs thread for task, runnable is winner. java designer recognizes this and that's why executors accept runnable as task and they have worker thread which executes those task. inheriting all thread methods are additional overhead just for representing a task which can be done easily with runnable. courtesy from javarevisited.blogspot.com these were some of notable difference between thread and runnable in java, if you know any other differences on thread vs runnable than please share it via comments. i personally use runnable over thread for this scenario and recommends to use runnable or callable interface based on your requirement. however, the significant difference is. when you code_removed class, each of your thread creates unique object and associate with it. when you code_removed, it shares the same object to multiple threads.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable",
				"runnable",
				"runnable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "can you relate your point to the size of an thread that extends a class - to implementing the runnable interface. the thread class already contains the runnable interface. so i assume it somehow are bigger in size. by using extended thread you need (thread: runnable interface - extending java.lang.object), but you can take out that runnable interface and use it independently. also is this not then just as comparing (ice cream) with (ice cream + ice cream hornet)?",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable",
				"runnable",
				"runnable",
				"runnable",
				"independently"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "sorry to see you got lots of down-votes for this. there is indeed very little reason to use java's linkedlist. in addition to the bad performance it also uses lots more memory than the other concrete list classes (every node has two additional pointers and each node is a separate wrapper object with the extra overhead bytes that go with them).",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"bad"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@drewnoakes you are right, i just wanted to point out. at school we had one assignment where we communicated through tcp using a simple text protocol (lines with commands) and sometimes a random very long string was sent to the clients just to test if students are coping with unexpected long values correctly.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"simple"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "@ted hopp: i can\u2019t speak for linux, but windows does clear memory pages. it\u2019s not clear why this should be slow at all, that happens once for each allocated page and it doesn\u2019t even need to happen on the allocation, but the first actual use, though there\u2019s also a background clearing of unused pages in advance when cpu cycles are free. the reason is exactly security. that doesn\u2019t affect the difference between code_removed and code_removed as these are not operating system, c library functions. so code_removed might return non-zero memory which the same program has freed earlier\u2026",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"exactly"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		}
	},
	{
		"comentario": "the question title seems to be wrong to me. the u000d character is in this case terminating the comment so the code is not in a comment at all. this is as nonsensical as asking thy the compiler parses the newline character at the end of the comment rather than going on forever. in the end this flaw stems from the inherent flaw of making comments line based in an otherwise non line based language.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"inherent"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@jeffolson meh, not really. map lookup is o(1) so both loops behave the same way. admittedly, it will be slightly slower in a micro benchmark but i sometimes do this as well because i hate writing the type arguments over and over again. also this will quite likely never be your performance bottleneck, so go for it if it makes the code more readable.",
		"aspectos": {
			"AvailabilityAndScalability": [
				"never"
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": -1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": -1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": 0,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": 0,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "reflection is a language's ability to inspect and dynamically call classes, methods, attributes, etc. at runtime. for example, all objects in java have the method code_removed, which lets you determine the object's class even if you don't know it at compile time (e.g. if you declared it as an code_removed) - this might seem trivial, but such reflection is not possible in less dynamic languages such as code_removed. more advanced uses lets you list and call methods, constructors, etc. reflection is important since it lets you write programs that do not have to \"know\" everything at compile time, making them more dynamic, since they can be tied together at runtime. the code can be written against known interfaces, but the actual classes to be used can be instantiated using reflection from configuration files. lots of modern frameworks use reflection extensively for this very reason. most other modern languages use reflection as well, and in scripting languages (such as python) they are even more tightly integrated, since it feels more natural within the general programming model of those languages.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"know"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "that's useful, but beware a small flaw: method signatures are like: nextdouble(double startinclusive, double endinclusive), but if you look inside the methods, endinclusive should actually be endexclusive.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"small"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@synderesis that's right, you won't see all the letters in the results. compactness is a tradeoff: if you are okay with special characters, there's base-64 encoding, or even base-85 encoding that uses a lot of symbols. but if you are using them in urls, that can be a pain to encode. the general principle is to round up the number of bits so that you use the full capacity of each \"digit\" in the encoding.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"general"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "what is reflection, and why is it useful? i'm particularly interested in java, but i assume the principles are the same in any language.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"same"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "some people believe that you have to overwrite the memory used to store the password once you no longer need it. this reduces the time window an attacker has to read the password from your system and completely ignores the fact that the attacker already needs enough access to hijack the jvm memory to do this. an attacker with that much access can catch your key events making this completely useless (afaik, so please correct me if i am wrong). update thanks to the comments i have to update my answer. apparently there are two cases where this can add a (very) minor security improvement as it reduces the time a password could land on the hard drive. still i think it's overkill for most use cases. your target system may be badly configured or you have to assume it is and you have to be paranoid about core dumps (can be valid if the systems are not managed by an administrator). your software has to be overly paranoid to prevent data leaks with the attacker gaining access to the hardware - using things like truecrypt (discontinued), veracrypt, or ciphershed. if possible, disabling core dumps and the swap file would take care of both problems. however, they would require administrator rights and may reduce functionality (less memory to use) and pulling ram from a running system would still be a valid concern.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"not"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "make everything private and only increase the scope of something as you need it.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"only"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "why use code_removed inside code_removed class in java? during code_removed, java runtime creates a version number for a class, so that it can de-serialize it later. this version number is known as code_removed in java. code_removed is used to version serialized data. you can only de-serialize a class if it's code_removed matches with the serialized instance. when we don't declare code_removed in our class, java runtime generates it for us but its not recommended. it's recommended to declare code_removed as code_removed variable to avoid default mechanism. when you declare a class as code_removed by implementing marker interface code_removed, java runtime persist instance of that class into disk by using default serialization mechanism, provided you have not customized the process using code_removed interface. see also why use serialversionuid inside serializable class in java code: javassist.serialversionuid",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"remove"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "i'm afraid your proposed optimisation is flawed: code_removed has implementation defined behavior: code_removed has code_removed type, so code_removed will be negative for values less than 128. right shifting a negative value has implementation defined behavior. you can fix this for 2's complement architectures with a simple expression: code_removed for which many compilers will produce code without jumps. alternatively, given the range of code_removed: code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"your propose"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i would say there is a third way: code_removed maybe this is influenced a bit by my recent heavy usage of javascript and actionscript 3, but this way your class doesn't need to implement a pretty vague interface like code_removed.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"pretty vague"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "i notice that the generated seeds are all very close to code_removed. it'd be interesting to find out how many different seeds could generate each string, but i have nowhere near the processing capability to achieve that in a reasonable, timely fashion.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"reasonable",
				"timely"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"nowhere"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "no doubt some of us would be interested in ways of identifying code that is problematic for the cpu's branch-predictor. the valgrind tool code_removed has a branch-predictor simulator, enabled by using the code_removed flag. running it over the examples in this question, with the number of outer loops reduced to 10000 and compiled with code_removed, gives these results: sorted: code_removed unsorted: code_removed drilling down into the line-by-line output produced by code_removed we see for the loop in question: sorted: code_removed unsorted: code_removed this lets you easily identify the problematic line - in the unsorted version the code_removed line is causing 164,050,007 mispredicted conditional branches (code_removed) under cachegrind's branch-predictor model, whereas it's only causing 10,006 in the sorted version. alternatively, on linux you can use the performance counters subsystem to accomplish the same task, but with native performance using cpu counters. code_removed sorted: code_removed unsorted: code_removed it can also do source code annotation with dissassembly. code_removed code_removed see the performance tutorial for more details.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"native"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "the reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in mysticial's answer. now, if we look at the code code_removed we can find that the meaning of this particular code_removed branch is to add something when a condition is satisfied. this type of branch can be easily transformed into a conditional move statement, which would be compiled into a conditional move instruction: code_removed, in an code_removed system. the branch and thus the potential branch prediction penalty is removed. in code_removed, thus code_removed, the statement, which would compile directly (without any optimization) into the conditional move instruction in code_removed, is the ternary operator code_removed. so we rewrite the above statement into an equivalent one: code_removed while maintaining readability, we can check the speedup factor. on an intel core i7-2600k @ 3.4\u00a0ghz and visual studio 2010 release mode, the benchmark is (format copied from mysticial): x86 code_removed x64 code_removed the result is robust in multiple tests. we get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. in fact, when using a conditional move, the performance is the same regardless of the data pattern. now let's look more closely by investigating the code_removed assembly they generate. for simplicity, we use two functions code_removed and code_removed. code_removed uses the conditional branch code_removed: code_removed code_removed uses the ternary operator code_removed: code_removed on a x86-64 machine, code_removed generates the assembly below. code_removed code_removed uses much less code due to the usage of instruction code_removed. but the real gain is that code_removed does not involve branch jumps, code_removed, which would have a significant performance penalty if the predicted result is not right. so why does a conditional move perform better? in a typical code_removed processor, the execution of an instruction is divided into several stages. roughly, we have different hardware to deal with different stages. so we do not have to wait for one instruction to finish to start a new one. this is called pipelining. in a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. we have to either wait or predict. in a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like code_removed and code_removed does not depend on the result of the previous instruction; only latter stages need the result. thus, we wait a fraction of one instruction's execution time. this is why the conditional move version is slower than the branch when prediction is easy. the book computer systems: a programmer's perspective, second edition explains this in detail. you can check section 3.6.6 for conditional move instructions, entire chapter 4 for processor architecture, and section 5.11.2 for a special treatment for branch prediction and misprediction penalties. sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can't (the code in question is using visual studio's native compiler). knowing the performance difference between branch and conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"regardless same",
				"good",
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "when does branch prediction takes place? when does language will know that array is sorted? i'm thinking of situation of array that looks like: [1,2,3,4,5,...998,999,1000, 3, 10001, 10002]? will this obscure 3 increase running time? will it be as long as unsorted array?",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"obscure"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@holger i was personally given that restriction when first starting out programming, and also when i had to write (pen/paper) similar interactions in a test. it's uncommon, but it's a method that is easily understood and while not being the most efficient by miles it's a method that works decently enough for small projects. so.se is meant to help everyone, not just a few. i provided an alternative method, for those who are starting out by learning how to create a pseudo-algorithm and turning it into an algorithm rather than using premade java expressions. although i did forget that '0' is cool",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"similar"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "code_removed is what you want. code_removed is almost always a (performance) bug. why code_removed sucks: it uses lots of small memory objects, and therefore impacts performance across the process. lots of small objects are bad for cache-locality. any indexed operation requires a traversal, i.e. has o(n) performance. this is not obvious in the source code, leading to algorithms o(n) slower than if code_removed was used. getting good performance is tricky. even when big-o performance is the same as code_removed, it is probably going to be significantly slower anyway. it's jarring to see code_removed in source because it is probably the wrong choice.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"therefore",
				"good",
				"big-o",
				"when same"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@petervdl heartbleed happened because someone got the great idea that reusing memory was cheaper than allocating new (cleared) memory, you cannot reuse a string in java, just hope that nobody ever gets the idea to put your char[] into a reuse list for better performance.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "they are serializable, have a zero-argument constructor, and allow access to properties using getter and setter methods. the name \"bean\" was given to encompass this standard, which aims to create reusable software components for java.code_removed wiki the objects that form the backbone of your application and that are managed by the spring ioc container are called beans. a bean is an object that is instantiated, assembled, and otherwise managed by a spring ioc container. otherwise, a bean is simply one of many objects in your application. code_removed spring io.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"otherwise"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "i think indexing with the 0/1 value will probably be faster than an integer multiply, but i guess if performance is really critical you should profile it. i agree that small lookup tables are essential to avoid cache pressure, but clearly if you have a bigger cache you can get away with a bigger lookup table, so 4kb is more a rule of thumb than a hard rule. i think you meant code_removed? that would be true for 32-bit. my two-year-old cell phone has a 32kb l1 cache, so even a 4k lookup table might work, especially if the lookup values were a byte instead of an int.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"really critical"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i don't care about small lists performance, and neither does my computer unless it is used in a loop somehow.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"small"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "when does branch prediction takes place? when does language will know that array is sorted? i'm thinking of situation of array that looks like: [1,2,3,4,5,...998,999,1000, 3, 10001, 10002]? will this obscure 3 increase running time? will it be as long as unsorted array?",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"obscure"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@somatik uuid.randomuuid() actually uses securerandom. still might not be a good idea if you want 128bit encryption. you will only get 122bits of random: stackoverflow.com/questions/7532807/\u2026",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"128bit"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		}
	},
	{
		"comentario": "rather unusual approach but in terms of code length (not performance) this is the easiest thing you could do: code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"not"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "it's about branch prediction. what is it? a branch predictor is one of the ancient performance improving techniques which still finds relevance into modern architectures. while the simple prediction techniques provide fast lookup and power efficiency they suffer from a high misprediction rate. on the other hand, complex branch predictions \u2013either neural based or variants of two-level branch prediction \u2013provide better prediction accuracy, but they consume more power and complexity increases exponentially. in addition to this, in complex prediction techniques the time taken to predict the branches is itself very high \u2013ranging from 2 to 5 cycles \u2013which is comparable to the execution time of actual branches. branch prediction is essentially an optimization (minimization) problem where the emphasis is on to achieve lowest possible miss rate, low power consumption, and low complexity with minimum resources. there really are three different kinds of branches: forward conditional branches - based on a run-time condition, the pc (program counter) is changed to point to an address forward in the instruction stream. backward conditional branches - the pc is changed to point backward in the instruction stream. the branch is based on some condition, such as branching backwards to the beginning of a program loop when a test at the end of the loop states the loop should be executed again. unconditional branches - this includes jumps, procedure calls and returns that have no specific condition. for example, an unconditional jump instruction might be coded in assembly language as simply \"jmp\", and the instruction stream must immediately be directed to the target location pointed to by the jump instruction, whereas a conditional jump that might be coded as \"jmpne\" would redirect the instruction stream only if the result of a comparison of two values in a previous \"compare\" instructions shows the values to not be equal. (the segmented addressing scheme used by the x86 architecture adds extra complexity, since jumps can be either \"near\" (within a segment) or \"far\" (outside the segment). each type has different effects on branch prediction algorithms.) static/dynamic branch prediction: static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code. references: branch predictor a demonstration of self-profiling branch prediction review branch prediction",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"ancient",
				"exponentially"
			],
			"Reliability": [
				"low"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": 0,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": 0,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "there is a new security flaw called branchscope: cs.ucr.edu/~nael/pubs/asplos18.pdf",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"new"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "lambda expression java 8 in java 1.8 (java 8) this has become lot easier by using foreach method from aggregate operations(stream operations) that looks similar to iterators from iterable interface. just copy paste below statement to your code and rename the hashmap variable from hm to your hashmap variable to print out key-value pair. code_removed below is the sample code that i tried using lambda expression. this stuff is so cool. must try. code_removed also one can use spliterator for the same. code_removed update including documentation links to oracle docs. for more on lambda go to this link and must read aggregate operations and for spliterator go to this link.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"iterable",
				"iterators"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "first i need to explain the serialization. serialization allows to convert the object to stream,for sending that object over the network or save to file or save into db for letter usage. there are some rules for serialization. an object is serializable only if its class or its superclass implements the serializable interface an object is serializable (itself implements the serializable interface) even if its superclass is not. however, the first superclass in the hierarchy of the serializable class, that does not implements serializable interface, must have a no-arg constructor. if this is violated, readobject() will produce a java.io.invalidclassexception in runtime all primitive types are serializable. transient fields (with transient modifier) are not serialized, (i.e., not saved or restored). a class that implements serializable must mark transient fields of classes that do not support serialization (e.g., a file stream). static fields (with static modifier) are not serialized. when object is serialized java runtime associates the serial version number that is called the serialversionid. where we need serialversionid: during the deserialization to verify that sender and receiver are compatible with respect to serialization.if receiver loaded the class with different serialversionid then deserialization will end with invalidclasscastexception. a serializable class can declare its own serialversionuid explicitly by declaring a field named \u201cserialversionuid\u201d that must be static, final, and of type long:. let's try this with an example. code_removed create serialize object code_removed deserializ the object code_removed note: now change the serialversionuid of the employee class and save: code_removed and execute the reader class. not to execute the writer class and you will get the exception. code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"serializable",
				"serializable",
				"serializable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "i respectfully disagree. good memory handling in java ( or almost any other language) will give you many benefits. from better stability as nullpointers reduced, better performance as lower memory footprint, to better design as relationships are better controlled. i will suggest that the sloppy memory management of many java applications leds to frequent npes and memory leaks.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good",
				"low"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@chris -- actually, i'll argue that not printing them is the solution, to the problem of getting accurate timings of the algorithm. each time you print to a console (of any sort), you're invoking all manner of external processing not related to what you're testing the performance of. that's a bug in your measurement procedure, pure and simple. on the other hand, if you view the problem not as measurement, but understanding the discrepancy, then yes, not printing is a debugging trick. it comes down to, which problem are you trying to solve?",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"not related"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "java 9 in java 9, you can use code_removed static factory method in order to create a code_removed literal. something like the following: code_removed this would return an immutable list containing three elements. if you want a mutable list, pass that list to the code_removed constructor: code_removed jep 269: convenience factory methods for collections jep 269 provides some convenience factory methods for java collections api. these immutable static factory methods are built into the code_removed, code_removed, and code_removed interfaces in java 9 and later.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"remove"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "everyone here seems to think that implementing runnable is the way to go and i don't really disagree with them but there is also a case for extending thread in my opinion, in fact you have sort of demonstrated it in your code. if you implement runnable then the class that implements runnable has no control over the thread name, it is the calling code that can set the thread name, like so: code_removed but if you extend thread then you get to manage this within the class itself (just like in your example you name the thread 'threadb'). in this case you: a) might give it a more useful name for debugging purposes b) are forcing that that name be used for all instances of that class (unless you ignore the fact that it is a thread and do the above with it as if it is a runnable but we are talking about convention here in any case so can ignore that possibility i feel). you might even for example take a stack trace of its creation and use that as the thread name. this might seem odd but depending on how your code is structured it can be very useful for debugging purposes. this might seem like a small thing but where you have a very complex application with a lot of threads and all of a sudden things 'have stopped' (either for reasons of deadlock or possibly because of a flaw in a network protocol which would be less obvious - or other endless reasons) then getting a stack dump from java where all the threads are called 'thread-1','thread-2','thread-3' is not always very useful (it depends on how your threads are structured and whether you can usefully tell which is which just by their stack trace - not always possible if you are using groups of multiple threads all running the same code). having said that you could of course also do the above in a generic way by creating an extension of the thread class which sets its name to a stack trace of its creation call and then use that with your runnable implementations instead of the standard java thread class (see below) but in addition to the stack trace there might be more context specific information that would be useful in the thread name for debugging (a reference to one of many queues or sockets it could processing for example in which case you might prefer to extend thread specifically for that case so that you can have the compiler force you (or others using your libraries) to pass in certain info (e.g. the queue/socket in question) for use in the name). here's an example of the generic thread with the calling stack trace as its name: code_removed and here's a sample of the output comparing the two names: code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"possibly"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "code_removed (introduced in java 5) is identical to code_removed, except its methods are not synchronized. this means it has better performance than the latter, but the drawback is that it is not thread-safe. read tutorial for more details.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@adrian: with tools to dump a process's memory. they exist for pretty much every platform. yes, you need to have a fair amount of access to the machine to start with, but it still increases the attacks you can do.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"still"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "a code_removed to quote spring documentation, indicates that an annotated class is a \"service\", originally defined by domain-driven design (evans, 2003) as \"an operation offered as an interface that stands alone in the model, with no encapsulated state.\" may also indicate that a class is a \"business service facade\" (in the core j2ee patterns sense), or something similar. this annotation is a general-purpose stereotype and individual teams may narrow their semantics and use as appropriate. if you look at domain driven design by eric evans, a service is an operation offered as an interface that stands alone in the model, without encapsulating state, as entities and value objects do. services are a common pattern in technical frameworks, but they can also apply in the domain layer. the name service emphasizes the relationship with other objects. unlike entities and value objects, it is defined purely in terms of what it can do for a client. a service tends to be named for an activity, rather than an entity\u2014a verb rather than a noun. a service can still have an abstract, intentional definition; it just has a different flavor than the definition of an object. a service should still have a defined responsibility, and that responsibility and the interface fulfilling it should be defined as part of the domain model. operation names should come from the ubiquitous language or be introduced into it. parameters and results should be domain objects. services should be used judiciously and not allowed to strip the entities and value objects of all their behavior. but when an operation is actually an important domain concept, a service forms a natural part of a model-driven design. declared in the model as a service, rather than as a phony object that doesn't actually represent anything, the standalone operation will not mislead anyone. and a code_removed as per eric evans, a repository represents all objects of a certain type as a conceptual set (usually emulated). it acts like a collection, except with more elaborate querying capability. objects of the appropriate type are added and removed, and the machinery behind the repository inserts them or deletes them from the database. this definition gathers a cohesive set of responsibilities for providing access to the roots of aggregates from early life cycle through the end.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"more elaborate",
				"query"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "can you cite the source of the suggestion? i can't really think of a reason for code_removed being more secure except maybe the most amateurish of threats.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
				"maybe amateurish"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 0,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "to quote an official document, the java cryptography architecture guide says this about code_removed vs. code_removed passwords (about password-based encryption, but this is more generally about passwords of course): it would seem logical to collect and store the password in an object of type code_removed. however, here's the caveat: code_removeds of type code_removed are immutable, i.e., there are no methods defined that allow you to change (overwrite) or zero out the contents of a code_removed after usage. this feature makes code_removed objects unsuitable for storing security sensitive information such as user passwords. you should always collect and store security sensitive information in a code_removed array instead. guideline 2-2 of the secure coding guidelines for the java programming language, version 4.0 also says something similar (although it is originally in the context of logging): guideline 2-2: do not log highly sensitive information some information, such as social security numbers (ssns) and passwords, is highly sensitive. this information should not be kept for longer than necessary nor where it may be seen, even by administrators. for instance, it should not be sent to log files and its presence should not be detectable through searches. some transient data may be kept in mutable data structures, such as char arrays, and cleared immediately after use. clearing data structures has reduced effectiveness on typical java runtime systems as objects are moved in memory transparently to the programmer. this guideline also has implications for implementation and use of lower-level libraries that do not have semantic knowledge of the data they are dealing with. as an example, a low-level string parsing library may log the text it works on. an application may parse an ssn with the library. this creates a situation where the ssns are available to administrators with access to the log files.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"password-based"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		}
	},
	{
		"comentario": "moreover, you can use objets.equals to avoid the check completely. the call will be inlined resulting in the same machine code and the same performance.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"same"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@bobkerns thanks for injecting some sanity into this thread! so many people don't seem to understand this. you need to be careful that you are only measuring the thing you are trying to measure",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"only"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i agree with @axel in that illegalargumentexception implies (as i use it anyway) that a precondition for the argument does not hold as it pertains to a constraint on the parameter. a null parameter is usually just \"a general error in programming\" and not an application/api specific constraint. to maintain a defensive fail-fast strategy, there's nothing stopping anyone for checking for a null and throwing a nullpointerexception... which exactly conveys what happened, namely, \"you didn't program it right\":)",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"defensive"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "code_removed and code_removed both implements code_removed and their methods and results are almost identical. however there are few differences between them which make one better over another depending on the requirement. arraylist vs linkedlist 1) code_removed code_removed search operation is pretty fast compared to the code_removed search operation. code_removed in code_removed gives the performance of code_removed while code_removed performance is code_removed. code_removed code_removed maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. on the other side code_removed implements doubly linked list which requires the traversal through all the elements for searching an element. 2) code_removed code_removed remove operation gives code_removed performance while code_removed gives variable performance: code_removed in worst case (while removing first element) and code_removed in best case (while removing last element). conclusion: linkedlist element deletion is faster compared to arraylist. reason: linkedlist\u2019s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. while in arraylist all the elements need to be shifted to fill out the space created by removed element. 3) code_removed code_removed add method gives code_removed performance while code_removed gives code_removed in worst case. reason is same as explained for remove. 4) code_removed code_removed maintains indexes and element data while code_removed maintains element data and two pointers for neighbor nodes hence the memory consumption is high in linkedlist comparatively. there are few similarities between these classes which are as follows: both arraylist and linkedlist are implementation of list interface. they both maintain the elements insertion order which means while displaying arraylist and linkedlist elements the result set would be having the same order in which the elements got inserted into the list. both these classes are non-synchronized and can be made synchronized explicitly by using collections.synchronizedlist method. the code_removed and code_removed returned by these classes are code_removed (if list is structurally modified at any time after the iterator is created, in any way except through the code_removed own remove or add methods, the iterator will code_removed a code_removed). when to use linkedlist and when to use arraylist? as explained above the insert and remove operations give good performance code_removed in code_removed compared to code_removed. hence if there is a requirement of frequent addition and deletion in application then linkedlist is a best choice. search (code_removed) operations are fast in code_removed but not in code_removed so if there are less add and remove operations and more search operations requirement, arraylist would be your best bet.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"variable"
			],
			"Reliability": [
				"high"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "iterator interface is generic since 1.2. it need to be iterator<e>",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"generic"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "yes, it is possible: code_removed to chain to a particular superclass constructor instead of one in the same class, use code_removed instead of code_removed. note that you can only chain to one constructor, and it has to be the first statement in your constructor body. see also this related question, which is about c# but where the same principles apply.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"same"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "a javabean is just a standard all properties private (use getters/setters) a public no-argument constructor implements code_removed. that's it. it's just a convention. lots of libraries depend on it though. with respect to code_removed, from the api documentation: serializability of a class is enabled by the class implementing the java.io.serializable interface. classes that do not implement this interface will not have any of their state serialized or deserialized. all subtypes of a serializable class are themselves serializable. the serialization interface has no methods or fields and serves only to identify the semantics of being serializable. in other words, serializable objects can be written to streams, and hence files, object databases, anything really. also, there is no syntactic difference between a javabean and another class -- a class defines a javabean if it follows the standards. there is a term for it because the standard allows libraries to programmatically do things with class instances you define in a predefined way. for example, if a library wants to stream any object you pass into it, it knows it can because your object is serializable (assuming the lib requires your objects be proper javabeans).",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"java.io.serializable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "though reusability of components is fine it targets some field",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
				"fine"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@konradmorawski imho package is smaller scope than subclass. if you haven't declared your class final, users should be able to subclass it - so java protected is part of your published interface. otoh, packages are implicitly developed by a single organization: e.g. com.mycompany.mypackage. if your code declares itself in my package, you implicitly declare yourself part of my organization, so we should be communicating. thus, package publishes to a smaller/easier to reach audience (people in my company) than subclass (people who extend my object) and so counts as lower visibility.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"publish"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "(caveat: i am not a java programmer, i am a perl programmer. perl has no formal protections which is perhaps why i understand the problem so well:) ) private like you'd think, only the class in which it is declared can see it. package private can only be seen and used by the package in which it was declared. this is the default in java (which some see as a mistake). protected package private + can be seen by subclasses or package member. public everyone can see it. published visible outside the code i control. (while not java syntax, it is important for this discussion). c++ defines an additional level called \"friend\" and the less you know about that the better. when should you use what? the whole idea is encapsulation to hide information. as much as possible you want to hide the detail of how something is done from your users. why? because then you can change them later and not break anybody's code. this lets you optimize, refactor, redesign and fix bugs without worry that someone was using that code you just overhauled. so, rule of thumb is to make things only as visible as they have to be. start with private and only add more visibility as needed. only make public that which is absolutely necessary for the user to know, every detail you make public cramps your ability to redesign the system. if you want users to be able to customize behaviors, rather than making internals public so they can override them, it's often a better idea to shove those guts into an object and make that interface public. that way they can simply plug in a new object. for example, if you were writing a cd player and wanted the \"go find info about this cd\" bit customizable, rather than make those methods public you'd put all that functionality into its own object and make just your object getter/setter public. in this way being stingy about exposing your guts encourages good composition and separation of concerns personally, i stick with just \"private\" and \"public\". many oo languages just have that. \"protected\" can be handy, but it's really a cheat. once an interface is more than private it's outside of your control and you have to go looking in other people's code to find uses. this is where the idea of \"published\" comes in. changing an interface (refactoring it) requires that you find all the code which is using it and change that, too. if the interface is private, well no problem. if it's protected you have to go find all your subclasses. if it's public you have to go find all the code which uses your code. sometimes this is possible, for example if you're working on corporate code that's for internal use only it doesn't matter if an interface is public. you can grab all the code out of the corporate repository. but if an interface is \"published\", if there is code using it outside your control, then you're hosed. you must support that interface or risk breaking code. even protected interfaces can be considered published (which is why i don't bother with protected). many languages find the hierarchical nature of public/protected/private to be too limiting and not in line with reality. to that end there is the concept of a trait class, but that's another show.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"no",
				"formal"
			],
			"Interoperability": [
				"once private",
				"private",
				"public",
				"even",
				"protect"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": 0
		}
	},
	{
		"comentario": "java does not support multiple inheritence so if you extends thread class then no other class will be extended. for example: if you create an applet then it must extends applet class so here the only way to create thread is by implementing runnable interface",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "eclipse, netbeans, less, gedit and emacs all have major performance issues with long lines. somehow they managed to write code that runs as something like o(n^2) in the length of the line. this is a common, dumb problem that really needs to be solved in all these programs.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"somehow"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "you will find serialization useful when deploying your project across multiple servers since beans will be persisted and transferred across them.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
				"when"
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": -1,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": -1,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 0,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 0,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "there are many great answers already on this question, but a lot of great libraries have come out since those answers were posted. this is intended as a kind of newbie-guide. i will cover several use cases for performing network operations and a solution or two for each. rest over http typically json, can be xml or something else full api access let's say you are writing an app that lets users track stock prices, interest rates and currecy exchange rates. you find an json api that looks something like this: code_removed retrofit from square this is an excellent choice for an api with multiple endpoints and allows you to declare the rest endpoints instead of having to code them individually as with other libraries like ion or volley. (website: how do you use it with the finances api? build.gradle add these lines to your module level buid.gradle: code_removed financesapi.java code_removed financesapibuilder code_removed financesfragment snippet code_removed if your api requires an api key or other header like a user token, etc. to be sent, retrofit makes this easy (see this awesome answer for details: one off rest api access let's say you're building a \"mood weather\" app that looks up the users gps location and checks the current temperature in that area and tells them the mood. this type of app doesn't need to declare api endpoints; it just needs to be able to access one api endpoint. ion this is a great library for this type of access. please read msysmilu's great answer ( load images via http volley volley can also be used for rest apis, but due to the more complicated setup required i prefer to use retrofit from square as above ( let's say you are building a social networking app and want to load profile pictures of friends. build.gradle add this line to your module level buid.gradle: code_removed imagefetch.java volley requires more setup than retrofit. you will need to create a class like this to setup a requestqueue, an imageloader and an imagecache, but it's not too bad: code_removed user_view_dialog.xml add the following to your layout xml file to add an image: code_removed userviewdialog.java add the following code to the oncreate method (fragment, activity) or the constructor (dialog): code_removed picasso another excellent library from square. please see the site for some great examples:",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
				"more complicated",
				"more"
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 1,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 1,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 1,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 1,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@bestass sorry, but code_removed is pretty well understood and how it behaves in the jvm... there are good reasons to use code_removed in place of code_removed when dealing with passwords in a secure manner.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"secure"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "if you can't use commons io (fileutils/ioutils/copyutils) here's an example using a bufferedreader to read the file line by line: code_removed or if you want raw speed i'd propose a variation on what paul de vrieze suggested (which avoids using a stringwriter (which uses a stringbuffer internally): code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"raw"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "there are no basic differences between stringbuilder and stringbuffer, only a few differences exist between them. in stringbuffer the methods are synchronized. this means that at a time only one thread can operate on them. if there are more than one thread then the second thread will have to wait for the first one to finish and the third one will have to wait for the first and second one to finish and so on. this makes the process very slow and hence the performance in case of stringbuffer is low. on the other hand stringbuilder is non synchronized. this means that at a time multiple threads can operate on the same strinbuilder object at the same time. this makes the process very fast and hence performance of stringbuilder is high.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"low",
				"very fast",
				"high"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@adam - if that's what you believe, then you severely misunderstand how to do event-driven development. please spend some time to learn about the difference between returning from event calls in a timely fashion as this platform requires vs. having your code not act on events until the whatever necessary prerequisites mandated by your needs have been met. to violate the platform requirements by blocking the ui thread as an unreliable shortcut is simply bad and unprofessional practice.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"timely"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i haven't managed to get it working just yet, but this is intended to solve exactly that problem.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"n't"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "rather unusual approach but in terms of code length (not performance) this is the easiest thing you could do: code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"not"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "no. your approach is absolutely wrong as you cannot stop the user from generating ui events. your contract with the android platform requires that you permit delivery of these in a timely fashion. the key to solving your problem in a compliant way is realizing that letting android report events to you does not mean that your program has to use those events. your refusal to adapt to the needs of the platform (such as by using the ui thread for translation only, not sequential program logic) is plainly and simply a refusal to do the job correctly.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"timely"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "learn to customize and write your own tags using jstl note that el is evil (runtime exceptions, refactoring) wicket may be evil too (performance, toilsome for small apps or simple view tier) example from java2s, this must be added to the web application's web.xml code_removed create file:java2s.tld in the /web-inf/ code_removed compile the following code into web-inf classes com java2s code_removed start server and load the bodycontent.jsp in browser code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"too"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "c++ does not, at this time, support type introspection in any relevant way. it is planned for a future version. some external tools (such as qt's moc) extend c++ with type introspection capabilities.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"c++"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "@bruno sure, hardware-based tokens do not suffer from this, but what about situations where you are more or less forced to use a software key? not every deployment has the budget to afford an hsm. software key stores will at some point have to load the key into memory, so imo we should at least be given the option to clear the memory at will again.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
				"not"
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": -1,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": -1,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 0,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": 0,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "not every language supports reflection but the principles are usually the same in languages that support it. reflection is the ability to \"reflect\" on the structure of your program. or more concrete. to look at the objects and classes you have and programmatically get back information on the methods, fields, and interfaces they implement. you can also look at things like annotations. it's usefull in a lot of situations. everywhere you want to be able to dynamically plug in classes into your code. lot's of object relational mappers use reflection to be able to instantiate objects from databases without knowing in advance what objects they're going to use. plug-in architectures is another place where reflection is usefull. being able to dynamically load code and determine if there are types there that implement the right interface to use as a plugin is important in those situations.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"right"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "@adamfreeman - sorting is relevant here only inasmuch as in this code it increases branch prediction to 100% success.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"only inasmuch"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@krisvandermotten yes, that's correct. what would also help in this case is use the correct data type (e.g. code_removed); that would eliminate the branch completely, which means more speed.:-) basically i always assume that if (1) you're in a tight loop with a limited amount of code (such as here) and (2) if you could predict the branches with 'static code analysis', then the processor / jit'ter will do their work properly.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"more"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "the problem though is that conceptually you don't want to teach people to take one potentially large data structure (an array) and then convert it to another large structure (a collection) just so that you can have that 2nd structure peruse itself. the most important reason being that 1. it's woefully unnecessary, and 2. the actual implementation of that collection search mechanism must be regarded as opaque because it can change in future revisions of java. it's a crummy idea on principle alone.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"alone"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i understood, i think, that a \"bean\" is a java class with properties and getters/setters. as much as i understand, it is the equivalent of a c struct. is that true? also, is there a real syntactic difference between a bean and a regular class? is there any special definition or an interface? basically, why is there a term for this? edit: if you can be so kind and add information regarding the code_removed interface, and what it means, to your answer, i'd be very grateful.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"remove"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "so an object can be changed by using its public interfaces but could not be replace with sth else i.e deference and by this java achieves best of both worlds",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"public"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "brilliant deduction. but we should generalize from this lesson, and always measure performance with output either eliminated, directed to /dev/null (nul on windows) or at least to a file. displaying on any sort of console is generally very expensive io, and always distorts timings -- even if not as dramatically confusingly as this.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"always"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "old and classic topic, just want to add this helpful blog that explains this: blog by manish chhabra the 5 main differences betwen hashmap and hashtable hashmap and hashtable both implement java.util.map interface but there are some differences that java developers must understand to write more efficient code. as of the java 2 platform v1.2, hashtable class was retrofitted to implement the map interface, making it a member of the java collections framework. one of the major differences between hashmap and hashtable is that hashmap is non-synchronized whereas hashtable is synchronized, which means hashtable is thread-safe and can be shared between multiple threads but hashmap cannot be shared between multiple threads without proper synchronization. java 5 introduced concurrenthashmap which is an alternative of hashtable and provides better scalability than hashtable in java.synchronized means only one thread can modify a hash table at one point of time. basically, it means that any thread before performing an update on a hashtable will have to acquire a lock on the object while others will wait for lock to be released. the hashmap class is roughly equivalent to hashtable, except that it permits nulls. (hashmap allows null values as key and value whereas hashtable doesn\u2019t allow nulls). the third significant difference between hashmap vs hashtable is that iterator in the hashmap is a fail-fast iterator while the enumerator for the hashtable is not and throw concurrentmodificationexception if any other thread modifies the map structurally by adding or removing any element except iterator\u2019s own remove() method. but this is not a guaranteed behavior and will be done by jvm on best effort. this is also an important difference between enumeration and iterator in java. one more notable difference between hashtable and hashmap is that because of thread-safety and synchronization hashtable is much slower than hashmap if used in single threaded environment. so if you don\u2019t need synchronization and hashmap is only used by one thread, it out perform hashtable in java. hashmap does not guarantee that the order of the map will remain constant over time. note that hashmap can be synchronized by code_removed in summary there are significant differences between hashtable and hashmap in java e.g. thread-safety and speed and based upon that only use hashtable if you absolutely need thread-safety, if you are running java 5 consider using concurrenthashmap in java.",
		"aspectos": {
			"AvailabilityAndScalability": [
				"good"
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": 1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": 1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": 1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": 1,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "reflection is an api which is used to examine or modify the behaviour of methods, classes, interfaces at runtime. the required classes for reflection are provided under code_removed. reflection gives us information about the class to which an object belongs and also the methods of that class which can be executed by using the object. through reflection we can invoke methods at runtime irrespective of the access specifier used with them. the code_removed and code_removed packages provide classes for java reflection. reflection can be used to get information about \u2013 class the code_removed method is used to get the name of the class to which an object belongs. constructors the code_removed method is used to get the public constructors of the class to which an object belongs. methods the code_removed method is used to get the public methods of the class to which an objects belongs. the reflection api is mainly used in: ide (integrated development environment) e.g. eclipse, myeclipse, netbeans etc. debugger and test tools etc. advantages of using reflection: extensibility features: an application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names. debugging and testing tools: debuggers use the property of reflection to examine private members on classes. drawbacks: performance overhead: reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications. exposure of internals: reflective code breaks abstractions and therefore may change behaviour with upgrades of the platform. ref: java reflection javarevisited.blogspot.in",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"slow"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "as you're writing the \"summary answer\", you should note that some solutions automatically convert different linebreaks (like code_removed) to code_removed which might be undesired in some cases. also it would be nice to see the additional memory required or at least allocation pressure (at least you may run jmh with code_removed). for the really cool post it would be great to see the graphs (depending on string length within the same input size and depending on the input size within the same string length).",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
				"least"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 0,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i generated two matrices of code_removed x code_removed: first matrix: code_removed and code_removed. second matrix: code_removed and code_removed. using the following code, the first matrix took 8.52 seconds to complete: code_removed with this code, the second matrix took 259.152 seconds to complete: code_removed what is the reason behind the dramatically different run times? as suggested in the comments, printing only code_removed takes code_removed seconds, whereas code_removed gives code_removed. as others who pointed out that it works for them normally, i tried ideone.com for instance, and both pieces of code execute at the same speed. test conditions: i ran this test from netbeans 7.2, with the output into its console i used code_removed for measurements",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"same"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "better use stringbuilder since it is not synchronized and therefor better performance. stringbuilder is a drop-in replacement of the older stringbuffer.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"therefor good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "it's about branch prediction. what is it? a branch predictor is one of the ancient performance improving techniques which still finds relevance into modern architectures. while the simple prediction techniques provide fast lookup and power efficiency they suffer from a high misprediction rate. on the other hand, complex branch predictions \u2013either neural based or variants of two-level branch prediction \u2013provide better prediction accuracy, but they consume more power and complexity increases exponentially. in addition to this, in complex prediction techniques the time taken to predict the branches is itself very high \u2013ranging from 2 to 5 cycles \u2013which is comparable to the execution time of actual branches. branch prediction is essentially an optimization (minimization) problem where the emphasis is on to achieve lowest possible miss rate, low power consumption, and low complexity with minimum resources. there really are three different kinds of branches: forward conditional branches - based on a run-time condition, the pc (program counter) is changed to point to an address forward in the instruction stream. backward conditional branches - the pc is changed to point backward in the instruction stream. the branch is based on some condition, such as branching backwards to the beginning of a program loop when a test at the end of the loop states the loop should be executed again. unconditional branches - this includes jumps, procedure calls and returns that have no specific condition. for example, an unconditional jump instruction might be coded in assembly language as simply \"jmp\", and the instruction stream must immediately be directed to the target location pointed to by the jump instruction, whereas a conditional jump that might be coded as \"jmpne\" would redirect the instruction stream only if the result of a comparison of two values in a previous \"compare\" instructions shows the values to not be equal. (the segmented addressing scheme used by the x86 architecture adds extra complexity, since jumps can be either \"near\" (within a segment) or \"far\" (outside the segment). each type has different effects on branch prediction algorithms.) static/dynamic branch prediction: static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code. references: branch predictor a demonstration of self-profiling branch prediction review branch prediction",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"ancient",
				"exponentially"
			],
			"Reliability": [
				"low"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": 0,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": 0,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "this is a very common problem for every java developer. so there is official support in java\u00a08 to address these issues without cluttered code. java 8 has introduced code_removed. it is a container that may or may not hold a non-null value. java 8 has given a safer way to handle an object whose value may be null in some of the cases. it is inspired from the ideas of haskell and scala. in a nutshell, the optional class includes methods to explicitly deal with the cases where a value is present or absent. however, the advantage compared to null references is that the optional<t> class forces you to think about the case when the value is not present. as a consequence, you can prevent unintended null pointer exceptions. in above example we have a home service factory that returns a handle to multiple appliances available in the home. but these services may or may not be available/functional; it means it may result in a nullpointerexception. instead of adding a null code_removed condition before using any service, let's wrap it in to optional<service>. wrapping to option<t> let's consider a method to get a reference of a service from a factory. instead of returning the service reference, wrap it with optional. it lets the api user know that the returned service may or may not available/functional, use defensively code_removed as you see code_removed provides an easy way to get the reference wrapped. there are another ways to get the reference of optional, either code_removed & code_removed. one for returning an empty object instead of retuning null and the other to wrap a non-nullable object, respectively. so how exactly it helps to avoid a null check? once you have wrapped a reference object, optional provides many useful methods to invoke methods on a wrapped reference without npe. code_removed optional.ifpresent invokes the given consumer with a reference if it is a non-null value. otherwise, it does nothing. code_removed represents an operation that accepts a single input argument and returns no result. unlike most other functional interfaces, consumer is expected to operate via side-effects. it is so clean and easy to understand. in the above code example, code_removed gets invoked if the optional holding reference is non-null. we use the ternary operator very often for checking null condition and return an alternative value or default value. optional provides another way to handle the same condition without checking null. optional.orelse(defaultobj) returns defaultobj if the optional has a null value. let's use this in our sample code: code_removed now homeservices.get() does same thing, but in a better way. it checks whether the service is already initialized of not. if it is then return the same or create a new new service. optional<t>.orelse(t) helps to return a default value. finally, here is our npe as well as null check-free code: code_removed the complete post is npe as well as null check-free code \u2026 really?.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"most",
				"other",
				"functional"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "@jonskeet - in this question stackoverflow.com/questions/22397861/\u2026, most answers say that string immutability is great for security, which is opposite of your answer here. their \"reasoning\" - strings are often used to store connections, passwords etc. and immutability prevents them from being changed. they don't mention how a mutable string value getting changed could be a security problem. there is no mention of techniques that can be used to change mutable strings. could you please clarify? thanks.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"great"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		}
	},
	{
		"comentario": "the reason enums work easily with == is because each defined instance is also a singleton. so identity comparison using == will always work. but using == because it works with enums means all your code is tightly coupled with usage of that enum. for example: enums can implement an interface. suppose you are currently using an enum which implements interface1. if later on, someone changes it or introduces a new class impl1 as an implementation of same interface. then, if you start using instances of impl1, you'll have a lot of code to change and test because of previous usage of ==. hence, it's best to follow what is deemed a good practice unless there is any justifiable gain.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"same"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "i think, the convention that is generally followed is this: static class within a top level class is a nested class non static class within a top level class is a inner class, which further has two more form: local class - named classes declared inside of a block like a method or constructor body anonymous class - unnamed classes whose instances are created in expressions and statements however, few other points to remembers are: top level classes and static nested class are semantically same except that in case of static nested class it can make static reference to private static fields/methods of its outer [parent] class and vice versa. inner classes have access to instance variables of the enclosing instance of the outer [parent] class. however, not all inner classes have enclosing instances, for example inner classes in static contexts, like an anonymous class used in a static initializer block, do not. anonymous class by default extends the parent class or implements the parent interface and there is no further clause to extend any other class or implement any more interfaces. so, code_removed means code_removed code_removed means code_removed i feel that the bigger question that remains open which one to use and when? well that mostly depends on what scenario you are dealing with but reading the reply given by @jrudolph may help you making some decision.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"more"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "@andreaslundgren if you annotated the persistence layer with code_removed or code_removed instead of code_removed, you lose the exception translation functionality. if you never code_removed specific persistence exceptions, or you don't care about the tight coupling of e.g. catching hibernate specific exceptions, then you don't care about the exception translation. similarly, if you annotate the service layer with something other than code_removed, you lose the ability to add service-layer specific pointcuts. if you never do that, you don't care, but using correct annotation is also good documentation",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"tight"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "code_removed hashtable is a data structure that retains values of key-value pair. it doesn\u2019t allow null for both the keys and the values. you will get a code_removed if you add null value. it is synchronized. so it comes with its cost. only one thread can access hashtable at a particular time. example: code_removed hashmap: hashmap is like hashtable but it also accepts key value pair. it allows null for both the keys and the values. its performance better is better than code_removed, because it is code_removed. example: code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "as per the wikipedia: the class must have a public default constructor (with no arguments). this allows easy instantiation within editing and activation frameworks. the class properties must be accessible using get, set, is (can be used for boolean properties instead of get), and other methods (so-called accessor methods and mutator methods) according to a standard naming convention. this allows easy automated inspection and updating of bean state within frameworks, many of which include custom editors for various types of properties. setters can have one or more than one argument. the class should be serializable. [this allows applications and frameworks to reliably save, store, and restore the bean's state in a manner independent of the vm and of the platform.] for more information follow this link.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"independent"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "the java tutorial says: terminology: nested classes are divided into two categories: static and non-static. nested classes that are declared static are simply called static nested classes. non-static nested classes are called inner classes. in common parlance, the terms \"nested\" and \"inner\" are used interchangeably by most programmers, but i'll use the correct term \"nested class\" which covers both inner and static. classes can be nested ad infinitum, e.g. class a can contain class b which contains class c which contains class d, etc. however, more than one level of class nesting is rare, as it is generally bad design. there are three reasons you might create a nested class: organization: sometimes it seems most sensible to sort a class into the namespace of another class, especially when it won't be used in any other context access: nested classes have special access to the variables/fields of their containing classes (precisely which variables/fields depends on the kind of nested class, whether inner or static). convenience: having to create a new file for every new type is bothersome, again, especially when the type will only be used in one context there are four kinds of nested class in java. in brief, they are: static class: declared as a static member of another class inner class: declared as an instance member of another class local inner class: declared inside an instance method of another class anonymous inner class: like a local inner class, but written as an expression which returns a one-off object let me elaborate in more details. static classes static classes are the easiest kind to understand because they have nothing to do with instances of the containing class. a static class is a class declared as a static member of another class. just like other static members, such a class is really just a hanger on that uses the containing class as its namespace, e.g. the class goat declared as a static member of class rhino in the package pizza is known by the name pizza.rhino.goat. code_removed frankly, static classes are a pretty worthless feature because classes are already divided into namespaces by packages. the only real conceivable reason to create a static class is that such a class has access to its containing class's private static members, but i find this to be a pretty lame justification for the static class feature to exist. inner classes an inner class is a class declared as a non-static member of another class: code_removed like with a static class, the inner class is known as qualified by its containing class name, pizza.rhino.goat, but inside the containing class, it can be known by its simple name. however, every instance of an inner class is tied to a particular instance of its containing class: above, the goat created in jerry, is implicitly tied to the rhino instance this in jerry. otherwise, we make the associated rhino instance explicit when we instantiate goat: code_removed (notice you refer to the inner type as just goat in the weird new syntax: java infers the containing type from the rhino part. and, yes new rhino.goat() would have made more sense to me too.) so what does this gain us? well, the inner class instance has access to the instance members of the containing class instance. these enclosing instance members are referred to inside the inner class via just their simple names, not via this (this in the inner class refers to the inner class instance, not the associated containing class instance): code_removed in the inner class, you can refer to this of the containing class as rhino.this, and you can use this to refer to its members, e.g. rhino.this.barry. local inner classes a local inner class is a class declared in the body of a method. such a class is only known within its containing method, so it can only be instantiated and have its members accessed within its containing method. the gain is that a local inner class instance is tied to and can access the final local variables of its containing method. when the instance uses a final local of its containing method, the variable retains the value it held at the time of the instance's creation, even if the variable has gone out of scope (this is effectively java's crude, limited version of closures). because a local inner class is neither the member of a class or package, it is not declared with an access level. (be clear, however, that its own members have access levels like in a normal class.) if a local inner class is declared in an instance method, an instantiation of the inner class is tied to the instance held by the containing method's this at the time of the instance's creation, and so the containing class's instance members are accessible like in an instance inner class. a local inner class is instantiated simply via its name, e.g. local inner class cat is instantiated as new cat(), not new this.cat() as you might expect. anonymous inner classes an anonymous inner class is a syntactically convenient way of writing a local inner class. most commonly, a local inner class is instantiated at most just once each time its containing method is run. it would be nice, then, if we could combine the local inner class definition and its single instantiation into one convenient syntax form, and it would also be nice if we didn't have to think up a name for the class (the fewer unhelpful names your code contains, the better). an anonymous inner class allows both these things: code_removed this is an expression returning a new instance of an unnamed class which extends parentclassname. you cannot supply your own constructor; rather, one is implicitly supplied which simply calls the super constructor, so the arguments supplied must fit the super constructor. (if the parent contains multiple constructors, the \u201csimplest\u201d one is called, \u201csimplest\u201d as determined by a rather complex set of rules not worth bothering to learn in detail--just pay attention to what netbeans or eclipse tell you.) alternatively, you can specify an interface to implement: code_removed such a declaration creates a new instance of an unnamed class which extends object and implements interfacename. again, you cannot supply your own constructor; in this case, java implicitly supplies a no-arg, do-nothing constructor (so there will never be constructor arguments in this case). even though you can't give an anonymous inner class a constructor, you can still do any setup you want using an initializer block (a {} block placed outside any method). be clear that an anonymous inner class is simply a less flexible way of creating a local inner class with one instance. if you want a local inner class which implements multiple interfaces or which implements interfaces while extending some class other than object or which specifies its own constructor, you're stuck creating a regular named local inner class.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"multiple"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "i feel like arguing about \"pass-by-reference vs pass-by-value\" is not super-helpful. if you say, \"java is pass-by-whatever (reference/value)\", in either case, you're not provide a complete answer. here's some additional information that will hopefully aid in understanding what's happening in memory. crash course on stack/heap before we get to the java implementation: values go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria. memory in the heap (also known as dynamic memory) is haphazard and disorganized. the jvm just finds space wherever it can, and frees it up as the variables that use it are no longer needed. okay. first off, local primitives go on the stack. so this code: code_removed results in this: when you declare and instantiate an object. the actual object goes on the heap. what goes on the stack? the address of the object on the heap. c++ programmers would call this a pointer, but some java developers are against the word \"pointer\". whatever. just know that the address of the object goes on the stack. like so: code_removed an array is an object, so it goes on the heap as well. and what about the objects in the array? they get their own heap space, and the address of each object goes inside the array. code_removed so, what gets passed in when you call a method? if you pass in an object, what you're actually passing in is the address of the object. some might say the \"value\" of the address, and some say it's just a reference to the object. this is the genesis of the holy war between \"reference\" and \"value\" proponents. what you call it isn't as important as that you understand that what's getting passed in is the address to the object. code_removed one string gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier code_removed, since the address of the second string is the same as the first, no new string is created and no new heap space is allocated, but a new identifier is created on the stack. then we call code_removed: a new stack frame is created and a new identifier, code_removed is created and assigned the address of the already-existing string. so, value, reference? you say \"potato\".",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"nice",
				"orderly"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "imho the pervasive, implicit localization in java is its single largest design flaw. it may be intended for user interfaces, but frankly, who really uses java for user interfaces today except for some ides where you can basically ignore localization because programmers aren't exactly the target audience for it. you can fix it (especially on linux servers) by: export lc_all=c tz=utc set your system clock to utc never use localized implementations unless absolutely necessary (ie for display only) to the java community process members i recommend: make localized methods not the default, but require the user to explicitly request localization. use utf-8/utc as the fixed default instead because that's simply the default today. there is no reason to do something else, except if you want to produce threads like this. i mean, come on, aren't global static variables an anti-oo pattern? nothing else is those pervasive defaults given by some rudimentary environment variables.......",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"single"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "yes by implementing runnable interface to are free to implement your own logic by extending any class, thats why runnable is mostly preferred over thread class.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "spring code_removed, code_removed, code_removed and code_removed annotations are used for automatic bean detection using classpath scan in spring framework. code_removed is a generic annotation. difference of code_removed, code_removed, code_removed with code_removed is they are special cases of code_removed and used for particular purposes. the difference is just classification only. for all these annotations (stereotypes), technically the core purpose is same. spring automatically scans and identifies all these classes that are annotated with \u201c code_removed, code_removed, code_removed, code_removed\u201d and registers bean definition with code_removed.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"just",
				"only"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "can you cite the source of the suggestion? i can't really think of a reason for code_removed being more secure except maybe the most amateurish of threats.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
				"maybe amateurish"
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": -1,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": 0,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "that's only true because you have not specified the locale in the parser input. that's bad coding style and a huge design flaw in java -- its inherent localization. personally, i put \"tz=utc lc_all=c\" everywhere i use java to avoid that. in addition you should avoid every localized version of an implementation unless you are directly interacting with a user and explicitly want it. don't to any calculations including localizations, always use locale.root and utc timezones unless absolutely necessary.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"huge"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i hope for being a java bean \"a class must be public\". and is it really need that it should implement serializable interface??",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"serializable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "the name reflection is used to describe code which is able to inspect other code in the same system (or itself). for example, say you have an object of an unknown type in java, and you would like to call a 'dosomething' method on it if one exists. java's static typing system isn't really designed to support this unless the object conforms to a known interface, but using reflection, your code can look at the object and find out if it has a method called 'dosomething' and then call it if you want to. so, to give you a code example of this in java (imagine the object in question is foo): code_removed one very common use case in java is the usage with annotations. junit 4, for example, will use reflection to look through your classes for methods tagged with the @test annotation, and will then call them when running the unit test. there are some good reflection examples to get you started at and finally, yes, the concepts are pretty much similar in other statically types languages which support reflection (like c#). in dynamically typed languages, the use case described above is less necessary (since the compiler will allow any method to be called on any object, failing at runtime if it does not exist), but the second case of looking for methods which are marked or work in a certain way is still common. update from a comment: the ability to inspect the code in the system and see object types is not reflection, but rather type introspection. reflection is then the ability to make modifications at runtime by making use of introspection. the distinction is necessary here as some languages support introspection, but do not support reflection. one such example is c++",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"known"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "according to my simple measures urlconn is 400-500ms faster than apache.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"simple",
				"fast 400-500ms"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i changed the string literal to something larger: \"the quick brown fox \" and got more interesting results. basically, they are about as fast. i actually ran out of memory so i had to remove a few sevens. explanation: the synchronization is optimized away by hotspot. you are basically just measuring the time it takes hotspot to do this (and probably some more optimizations).",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"basically",
				"just"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@adrian: with tools to dump a process's memory. they exist for pretty much every platform. yes, you need to have a fair amount of access to the machine to start with, but it still increases the attacks you can do.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"still"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i notice that the generated seeds are all very close to code_removed. it'd be interesting to find out how many different seeds could generate each string, but i have nowhere near the processing capability to achieve that in a reasonable, timely fashion.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"reasonable",
				"timely"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"nowhere"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "i want to complement polygenelubricants answer: i personally prefer equals(). but it lake the type compatibility check. which i think is an important limitation. to have type compatibility check at compilation time, declare and use a custom function in your enum. code_removed with this, you got all the advantage of both solution: npe protection, easy to read code and type compatibility check at compilation time. i also recommend to add an undefined value for enum.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"easy"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		}
	},
	{
		"comentario": "most of the answers do specify the main differences between hashmap and hashtable, here i'll just put them all together in my own words. similarities both expose the same interface for adding, removing and accessing elements from the memory. get(): retrieve an item by a key. remove(): remove an item by a key. put(): add an item both belong to the same package java.util. differences hashtable is implicitly synchronized, it works perfectly with multi-threaded environments. upon each access, the thread acquires a lock on the hashtable hence preventing any other thread from modifying it simultaneously. in contrast, hashmap is not thread safe and is only suitable for single-threaded environments. if you want to use hashmap in a multi threaded environment you can use concurrenthashmap. hashmap is faster than hashtable due to the fact that hashtable implicitly checks for synchronization on each method call even in a single thread environment. hashmap allows storing null values, while hashtable doesn\u2019t. hashmap can be iterated by an iterator which is considered as fail-fast. i.e. if any other thread modifies the map while iterating over it then a concurrentmodificationexception exception is thrown. however, hashtable is iterated by an enumerator which is not fail-fast. hashmap allows ordering and sorting its items through linkedhashmap and treemap implementations, while this is not feasible with hashtable. in short, hashtable is deprecated and replaced officially by concurrenthashmap, there is no reason for using it in new projects unless you\u2019re working in a legacy code which doesn\u2019t support hashmap (ideally there shouldn\u2019t be an applications which just compile on versions < 1.2 as hashmap is introduced in jdk 1.2). reference: hashtable vs hashmap",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"same"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "a code_removed \u2014 sometimes called a container \u2014 is simply an object that groups multiple elements into a single unit. code_removeds are used to store, retrieve, manipulate, and communicate aggregate data. a collections framework w is a unified architecture for representing and manipulating collections. the code_removed code_removed and hashtable code_removed, both are used to represent a group of objects that are represented in code_removed pair. each code_removed pair is called code_removed object. the collection of entries is referred by the object of code_removed and code_removed. keys in a collection must be unique or distinctive. [as they are used to retrieve a mapped value a particular key. values in a collection can be duplicated.] \u00ab superclass, legacy and collection framework member hashtable is a legacy class introduced in code_removed, which is a subclass of dictionary class. from code_removed hashtable is re-engineered to implement the map interface to make a member of collection framework. hashmap is a member of java collection framework right from the beginning of its introduction in code_removed. hashmap is the subclass of the abstractmap class. code_removed \u00ab initial capacity and load factor the capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. note that the hash table is open: in the case of a \"code_removedcode_removed\", a single bucket stores multiple entries, which must be searched sequentially. the load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. hashmap constructs an empty hash table with the default initial capacity (16) and the default load factor (0.75). where as hashtable constructs empty hashtable with a default initial capacity (11) and load factor/fill ratio (0.75). \u00ab structural modification in case of hash collision code_removed, code_removed in case of hash collisions they store the map entries in linked lists. from java8 for code_removed if hash bucket grows beyond a certain threshold, that bucket will switch from code_removed. which improve worst-case performance from o(n) to o(log n). while converting the list to binary tree, hashcode is used as a branching variable. if there are two different hashcodes in the same bucket, one is considered bigger and goes to the right of the tree and other one to the left. but when both the hashcodes are equal, code_removed assumes that the keys are comparable, and compares the key to determine the direction so that some order can be maintained. it is a good practice to make the keys of code_removed comparable. on adding entries if bucket size reaches code_removed convert linked list of entries to a balanced tree, on removing entries less than code_removed and at most code_removed will reconvert balanced tree to linked list of entries. java 8 src, stackpost \u00ab collection-view iteration, fail-fast and fail-safe code_removed code_removed is a fail-fast in nature. i.e it throws concurrentmodificationexception if a collection is modified while iterating other than it\u2019s own remove() method. where as code_removed is fail-safe in nature. it doesn\u2019t throw any exceptions if a collection is modified while iterating. according to java api docs, iterator is always preferred over the enumeration. note: the functionality of enumeration interface is duplicated by the iterator interface. in addition, iterator adds an optional remove operation, and has shorter method names. new implementations should consider using iterator in preference to enumeration. in java 5 introduced concurrentmap interface: code_removed - a highly concurrent, high-performance code_removed implementation backed by a hash table. this implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. it is intended as a drop-in replacement for code_removed: in addition to implementing code_removed, it supports all of the \"legacy\" methods peculiar to code_removed. each code_removeds value is volatile thereby ensuring fine grain consistency for contended modifications and subsequent reads; each read reflects the most recently completed update iterators and enumerations are fail safe - reflecting the state at some point since the creation of iterator/enumeration; this allows for simultaneous reads and modifications at the cost of reduced consistency. they do not throw concurrentmodificationexception. however, iterators are designed to be used by only one thread at a time. like code_removed but unlike code_removed, this class does not allow null to be used as a key or value. code_removed \u00ab null keys and null values code_removed allows maximum one null key and any number of null values. where as code_removed doesn\u2019t allow even a single null key and null value, if the key or value null is then it throws nullpointerexception. example \u00ab synchronized, thread safe code_removed is internally synchronized. therefore, it is very much safe to use code_removed in multi threaded applications. where as code_removed is not internally synchronized. therefore, it is not safe to use code_removed in multi threaded applications without external synchronization. you can externally synchronize code_removed using code_removed method. \u00ab performance as code_removed is internally synchronized, this makes code_removed slightly slower than the code_removed. @see a red\u2013black tree is a kind of self-balancing binary search tree performance improvement for code_removed in java 8",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"automatically",
				"worst-case"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"introduce"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "code_removed (introduced in java 5) is identical to code_removed, except its methods are not synchronized. this means it has better performance than the latter, but the drawback is that it is not thread-safe. read tutorial for more details.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"good"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "to quote an official document, the java cryptography architecture guide says this about code_removed vs. code_removed passwords (about password-based encryption, but this is more generally about passwords of course): it would seem logical to collect and store the password in an object of type code_removed. however, here's the caveat: code_removeds of type code_removed are immutable, i.e., there are no methods defined that allow you to change (overwrite) or zero out the contents of a code_removed after usage. this feature makes code_removed objects unsuitable for storing security sensitive information such as user passwords. you should always collect and store security sensitive information in a code_removed array instead. guideline 2-2 of the secure coding guidelines for the java programming language, version 4.0 also says something similar (although it is originally in the context of logging): guideline 2-2: do not log highly sensitive information some information, such as social security numbers (ssns) and passwords, is highly sensitive. this information should not be kept for longer than necessary nor where it may be seen, even by administrators. for instance, it should not be sent to log files and its presence should not be detectable through searches. some transient data may be kept in mutable data structures, such as char arrays, and cleared immediately after use. clearing data structures has reduced effectiveness on typical java runtime systems as objects are moved in memory transparently to the programmer. this guideline also has implications for implementation and use of lower-level libraries that do not have semantic knowledge of the data they are dealing with. as an example, a low-level string parsing library may log the text it works on. an application may parse an ssn with the library. this creates a situation where the ssns are available to administrators with access to the log files.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"password-based"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": -1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": 0,
			"Interoperability": null
		}
	},
	{
		"comentario": "@pauldevrieze how many lines, and how quickly do you need to process them!? i would hazard a guess that any performance loss would be small, or could be handled by every once in a while logging them to a file and destroying the old string obj's.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"small"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "i am somewhat curious as to the performance of this versus the searching functions in the arrays class versus iterating over an array and using an equals() function or == for primitives.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"somewhat curious"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "instead of using the quick array initialsation syntax to you could just initialise it as a list straight away in a similar manner using the arrays.aslist method e.g.: code_removed then you can do (like above): code_removed",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"similar"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "the simple answer in java 8 or earlier: code_removed this will give you a code_removed backed by the array, so it cannot change length. but you can call code_removed, so it's still mutable. in java 9: code_removed this will give you an immutable code_removed, so it cannot be changed. which is what you want in most cases where you're prepopulating it. the shorter answer you can make code_removed even shorter with a static import: code_removed the static import: code_removed which any modern ide will suggest and automatically do for you. for example in intellij idea you press code_removed and select code_removed. however, i don't recommend shortening the java 9 code_removed method, because having just code_removed becomes confusing. code_removed is already short enough and reads well. using code_removeds why does it have to be a code_removed? with java 8 or later you can use a code_removed which is more flexible: code_removed you can concatenate code_removeds: code_removed or you can go from a code_removed to a code_removed: code_removed but preferably, just use the code_removed without collecting it to a code_removed. if you really specifically need a code_removed (you probably don't.) to quote jep 269 (emphasis mine): there is a small set of use cases for initializing a mutable collection instance with a predefined set of values. it's usually preferable to have those predefined values be in an immutable collection, and then to initialize the mutable collection via a copy constructor. if you want to both prepopulate an code_removed and add to it afterwards (why?), use code_removed or in java 9: code_removed or using code_removed: code_removed but again, it's better to just use the code_removed directly instead of collecting it to a code_removed. program to interfaces, not to implementations you said you've declared the list as an code_removed in your code, but you should only do that if you're using some member of code_removed that's not in code_removed. which you are most likely not doing. usually you should just declare variables by the most general interface that you are going to use (e.g. code_removed, code_removed, or code_removed), and initialize them with the specific implementation (e.g. code_removed, code_removed or code_removed). otherwise you're limiting your code to that specific type, and it'll be harder to change when you want to. for example: code_removed another example would be always declaring variable an code_removed even though it is usually a code_removed or a code_removed, because one day soon you or somebody else will want to use some other kind of code_removed.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"most general"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "good article. i do not like to talk about pointers together with java though.. when one knows how java and its variables scope/lifetime work, reference is the term to use. with pointers people start wondering about pointing pointers or given that a reference is a pointer, about dereferencing a reference in a c++ fashion. that's not good. a variable is made of bits -a value-, and this value can reference an object. that is, it tells the jvm how to find an object in the heap. this value is copied/duplicated and passed to a method variable that then can find the same object. no need for pointers.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"c++"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "@smwikipedia: to deserialize data? yes. it would be odd to deserialize data for a class you didn't have the source to though. binary serialization shouldn't (imo) be used as a general purpose public protocol.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"general",
				"public"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		}
	},
	{
		"comentario": "@michaelb\u00f6ckling yes, the first method is written that way more as a consequence of the way code_removed works, and it doesn't provide a consistent output length or maximum bits of entropy per character. if you want the best security and best efficiency, i would use the second method, but initialize code_removed with a code_removed instance.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"best"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
				"best"
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": 1,
			"Interoperability": null
		}
	},
	{
		"comentario": "in that regard, i believe it works in the same manner as c++ (construct inherited portion, initialise object from initialisation list, run body of constructor), but with cleaner, but less specific, syntax (the initialisation list is moved to the top of the constructor's body, instead of being after the signature but before the body), with delegation passing the job of actually creating the object to the other constructor, and then running any code in the delegating constructor on a valid object after the constructor it delegates to returns. correct me if i'm wrong.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
				"same"
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": -1,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": 0,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "as answered before, there are many ways of dealing with exceptions in junit. but with java 8 there is another one: using lambda expressions. with lambda expressions we can achieve a syntax like this: code_removed assertthrown accepts a functional interface, whose instances can be created with lambda expressions, method references, or constructor references. assertthrown accepting that interface will expect and be ready to handle an exception. this is relatively simple yet powerful technique. have a look at this blog post describing this technique: the source code can be found here: disclosure: i am the author of the blog and the project.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"functional"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "much of this revolves around serialization and why it should probably not be used as an over-the-wire protocol or persistently stored and retrieved via deserialization. it effectively creates an implementation of \"equals\" at the class-level and without any reasonable method across jvms and countless apps/classes created by any number of developers to make this consistent/unique for a given class... creates a nuanced bug immediately for junior developers should they persist the class as serialized data and then let the compiler try to sort out the version of a class during deserialization.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"over-the-wire"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "difference between thread and runnable.if we are creating thread using thread class then number of thread equal to number of object we created . if we are creating thread by implementing the runnable interface then we can use single object for creating multiple thread.so single object is shared by multiple thread.so it will take less memory so depending upon the requirement if our data is not senstive. so it can be shared between multiple thread we can used runnable interface.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable",
				"runnable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "hashmap and hashtable some important points about hashmap and hashtable. please read below details. 1) hashtable and hashmap implement the java.util.map interface 2) both hashmap and hashtable is the hash based collection. and working on hashing. so these are similarity of hashmap and hashtable. what is the difference between hashmap and hashtable? 1) first difference is hashmap is not thread safe while hashtable is threadsafe 2) hashmap is performance wise better because it is not thread safe. while hashtable performance wise is not better because it is thread safe. so multiple thread can not access hashtable at the same time.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"hashtable",
				"wise"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "javabeans are java classes which adhere to an extremely simple coding convention. all you have to do is to implement java.io.serializable interface - to save the state of an object use a public empty argument constructor - to instantiate the object and provide public getter and setter methods - to get and set the values of private variables (properties ).",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"java.io.serializable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "one difference between implementing runnable and extending thread is that by extending thread, each of your threads has a unique object associated with it, whereas implementing runnable, many threads can share the same object instance. a class that implements runnable is not a thread and just a class. for a runnable to be executed by a thread, you need to create an instance of thread and pass the runnable instance in as the target. in most cases, the runnable interface should be used if you are only planning to override the run() method and no other thread methods. this is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class. when there is a need to extend a superclass, implementing the runnable interface is more appropriate than using the thread class. because we can extend another class while implementing runnable interface to make a thread. but if we just extend the thread class we can't inherit from any other class.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"runnable",
				"runnable",
				"runnable"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "can you specifically release your code to public domain, pretty please?",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"public"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 1
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	},
	{
		"comentario": "i changed the string literal to something larger: \"the quick brown fox \" and got more interesting results. basically, they are about as fast. i actually ran out of memory so i had to remove a few sevens. explanation: the synchronization is optimized away by hotspot. you are basically just measuring the time it takes hotspot to do this (and probably some more optimizations).",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
				"basically",
				"just"
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": -1,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": 0,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": null
		}
	},
	{
		"comentario": "code_removed facilitates versioning of serialized data. its value is stored with the data when serializing. when de-serializing, the same version is checked to see how the serialized data matches the current code. if you want to version your data, you normally start with a code_removed of 0, and bump it with every structural change to your class which alters the serialized data (adding or removing non-transient fields). the built-in de-serialization mechanism (code_removed) will refuse to de-serialize from old versions of the data. but if you want to you can define your own readobject()-function which can read back old data. this custom code can then check the code_removed in order to know which version the data is in and decide how to de-serialize it. this versioning technique is useful if you store serialized data which survives several versions of your code. but storing serialized data for such a long time span is not very common. it is far more common to use the serialization mechanism to temporarily write data to for instance a cache or send it over the network to another program with the same version of the relevant parts of the codebase. in this case you are not interested in maintaining backwards compatibility. you are only concerned with making sure that the code bases which are communicating indeed have the same versions of relevant classes. in order to facilitate such a check, you must maintain the code_removed just like before and not forget to update it when making changes to your classes. if you do forget to update the field, you might end up with two different versions of a class with different structure but with the same code_removed. if this happens, the default mechanism (code_removed) will not detect any difference, and try to de-serialize incompatible data. now you might end up with a cryptic runtime error or silent failure (null fields). these types of errors might be hard to find. so to help this usecase, the java platform offers you a choice of not setting the code_removed manually. instead, a hash of the class structure will be generated at compile-time and used as id. this mechanism will make sure that you never have different class structures with the same id, and so you will not get these hard-to-trace runtime serialization failures mentioned above. but there is a backside to the auto-generated id strategy. namely that the generated ids for the same class might differ between compilers (as mentioned by jon skeet above). so if you communicate serialized data between code compiled with different compilers, it is recommended to maintain the ids manually anyway. and if you are backwards-compatible with your data like in the first use case mentioned, you also probably want to maintain the id yourself. this in order to get readable ids and have greater control over when and how they change.",
		"aspectos": {
			"AvailabilityAndScalability": [
			],
			"Maintainability": [
			],
			"Performance": [
			],
			"Reliability": [
			],
			"Deployability": [
			],
			"Securability": [
			],
			"Interoperability": [
				"auto-generated"
			]
		},
		"clas_modelo": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": -1
		},
		"clas_modelo_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		},
		"clas_tb_no_neutro": {
			"AvailabilityAndScalability": null,
			"Maintainability": null,
			"Performance": null,
			"Reliability": null,
			"Deployability": null,
			"Securability": null,
			"Interoperability": 0
		}
	}
]
